    2ЛАБОРАТОРНАЯ РАБОТА 7.
    2АЛГОРИТМЫ СОРТИРОВКИ: временная эффективность

 ш1.0
                               1Лучше, если тебе скажут 0: 1 взойди 0  1выше,
                               1нежели 0: 1 сойди вниз.
                                                              1Талмуд
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Основные понятия . 0:
 ш1.0
   - " 1внутренние методы сортировки 0", " 1внешние методы сортировки 0";
    1- "сортировка  обменом",  "сортировка включениями",  "сортировка
 1выбором", "быстрая сортировка" 0;
   - " 1сортировка слиянием 0", " 1пирамидальная сортировка 0";
    1- асимптотические  оценки алгоритмов сортировки элементов в мас-
 1сиве 0.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   -  1использовать встроенные функции для сортировки списков 0.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                   2Алгоритмы сортировки в массиве

 ш1.0
                                 1Порядок ведёт ко всем добродетелям 0!
                                 1Но что ведёт к порядку 0?
                                                      1Г.К.Лихтенберг
 ш1.2

                        21. 0  3Сортировка обменом
    _ 1Сортировка обменом . 0 - это термин,  используемый для описания  се-
мейства методов сортировки, предусматривающих систематический обмен
местами между элементами пар, в которых нарушается упорядоченность,
до тех пор, пока таких пар не останется.
    2Определение 0.
 ш1.1
    _ 1Сортировка обменом . 0  - это метод сортировки,  при котором все со-
седние элементы списка попарно сравниваются друг с другом и меняют-
ся местами в том случае,  если предшествующий элемент больше после-
дующего.  В результате этого максимальный элемент постепенно смеща-
ется вправо по списку и в конце концов занимает крайнее правое мес-
то в списке, после чего он исключается из дальнейшей обработки.
   Затем процесс повторяется, и своё место занимает второй по вели-
чине элемент,  который также исключается из дальнейшего  рассмотре-
ния. Так продолжается пока весь список не будет упорядочен.

 ш1.2
   Опишем более формально этот алгоритм применительно к  упорядочи-
ванию по возрастанию списка попарно различных чисел x 41 0,x 42 0,...,x 4n 0.
   Последовательным просмотром элементов x 41 0,...,x 4n 0 найдём i  такое,
что x 4i 0>x 4i+1 0;  поменяем x 4i 0 и x 4i+1 0 местами, 4  0продолжим просмотр с эле-
мента x 4i+1 0 и т.д. Тем самым в результате первого просмотра наиболь-
шее число передвинется на последнее место в списке.
   Следующие просмотры начинают вновь сначала,  уменьшая на единицу
количество просматриваемых элементов. Список будет упорядочен после
просмотра, в котором участвовали только первый и второй элементы.
   Сортировку обменом называют ещё " 1пузырьковой 0  1сортировкой 0" (в си-
лу очевидного сравнения с всплытием пузырьков воздуха в жидкости).
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 4.

 ш1.2
   Ясно, что  если на очередном проходе массива не будет сделано ни
одного обмена,  то массив уже упорядочен. Учтём этот факт в следую-
щей программе, полученной несущественным усложнением процедуры сор-
тировки ( 1каким 0?). Это может дать существенный выигрыш в скорости.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
    3Замечание 0 [Лорин,1983,с.24].
 ш1.1
   Простыми формами сортировки обменом являются:  _ 1стандартный обмен . 0,
 _ 1парный обмен .  0и  _ 1просеивание . 0.

 ш1.2
                       22. 0  3Сортировка вставками
    2Определение 0 [Лорин,1983,с.33].
 ш1.1
    _ 1Сортировка вставками . 2  0- это название группы  методов  сортировки,
основанных на последовательной вставке новых элементов в увеличива-
ющийся упорядоченный список.
   Среди методов сортировки вставками имеются три метода  ( _ 1линейная
 _ 1вставка ., 0  _ 1центрированная вставка . и  _двоичная вставка . 0), которые разли-
чаются способом поиска подходящего места для вставки элемента.

 ш1.2
   Простейшим методом является  1линейная вставка 0.  В этом методе уже
существующий список рассматривается как линейный список, просматри-
ваемый поэлементно,  пока не будет найдена соответствующая  позиция
для нового элемента.
   Линейная вставка обычно используется тогда, когда процесс, внеш-
ний к данной сортировке,  динамически вносит добавления  в  список,
все  элементы  которого  известны и который должен поддерживаться в
упорядоченном состоянии.  Сортировка выполняется каждый раз при по-
лучении нового элемента, размещая этот элемент в нужное место спис-
ка.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 5.

 ш1.2
    3Замечание 0.
 ш1.1
   Сортировка вставками наиболее эффективна для случая почти упоря-
доченного массива.

 ш1.2
                        23. 0  3Сортировка выбором
    2Определение 0.
 ш1.1
    _ 1Сортировка выбором . 0 - это метод сортировки,  при котором в неупо-
рядоченной последовательности выбирается минимальный элемент, кото-
рый исключается из дальнейшей обработки,  а  оставшаяся  последова-
тельность элементов принимается за исходную. Процесс повторяется до
тех пор, пока все элементы не будут выбраны. Очевидно, что все выб-
ранные элементы образуют упорядоченную последовательность.

 ш1.2
   Минимальный элемент,  выбранный в  исходной  последовательности,
может быть размещён на предназначенном ему месте упорядоченной пос-
ледовательности несколькими способами. Рассмотрим два из них:
 ш1.1
   (1) минимальный элемент после i-го просмотра перемещается на i-е
место  (i=1,2,3,...) заданного списка,  а элемент с i-го места - на
место выбранного.  После каждого просмотра  упорядоченные  элементы
(от первого до элемента с индексом i) исключаются из дальнейшей об-
работки, т.е. размер каждого последующего обрабатываемого списка на
единицу меньше размера предыдущего;
   (2) минимальный элемент после i-го просмотра перемещается на i-е
место, i=1,2,3,...,  другого специально созданного списка,  а в ис-
ходном  списке,  на месте выбранного элемента размещается некоторое
число, превосходящее по величине любой элемент сортируемого списка.
Изменённый подобным образом список принимается за исходный,  и осу-
ществляется следующий просмотр.

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 6.

                        24. 0  3Быстрая сортировка

 ш1.0
            1Всё становится интуитивно ясным после того, как поймёшь.
                                                    1Автор неизвестен
 ш1.2

   Алгоритм сортировки, разработанный английским информатиком Ч.Хоа-
ром действует следующим образом. На первом этапе выбирается элемент,
называемый  _ 1опорным элементом . 0.  Далее необходимо расположить элементы
таким образом,  чтобы элементы меньше опорного находились  слева,  а
больше или равные элементы находились справа.
   Далее необходимо рекурсивно повторить поиск для  левых  и  правых
подмассивов.
   Обсудим сложность этого алгоритма.
   В общем случае на каждом шаге алгоритм делит массив пополам.
   Поэтому на каждом уровне рекурсии происходит  оперирование  с  n
элементами  массива  (списка),  а количество  1уровней рекурсии 0 равно
 1log 0(n), следовательно сложность быстрой сортировки  _ 1в среднем случае
составляет
 ш1.0

    7O 0(n 77 1log 0(n)).

 ш1.2
   Однако может возникнуть случай,  при котором массив (список) де-
лится не на две примерно равны части,  или даже случай, при котором
подмассив (подсписок) становится "пустым".
   В таком случае количество  1уровней рекурсии 0 может вырасти до n, и
в результате сложность быстрой сортировки  _ 1в худшем случае . 0 составля-
ет
 ш1.0

    7O 0(n 52 0).

 ш1.2
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 7, Пример 8.

 ш1.2
    3Замечание 0 ( 1важное 0).
 ш1.1
   Существуют несколько вариантов быстрой сортировки, которые  раз-
личаются в  деталях;  есть даже версия в исполнении  _ 1венгерского ан-
 _ 1самбля народных танцев . 0
   (см. https://www.youtube.com/watch?v=ywWBy6J5gz8.)

 ш1.2
                        25. 0  3Быстрая сортировка
                      ( 1библиотечная функция 0)
   Функция  3qsort 0() сортирует массив, адресуемый параметром-указате-
лем buf.  Количество элементов в массиве задаётся параметром num, а
размер (в байтах) каждого элемента - параметром size.
   Для сравнения двух элементов массива используется функция, пере-
даваемая через параметр compare.
   Функция compare должна иметь следующее описание:
 ш1.0

   #include<stdlib.h>
   void qsort(void *buf,size_t num,size_t size,
              int (*compare) (const void *,const void *));

 ш1.2
   Она должна возвращать значения, описанные ниже:
 ш1.0

   arg1<arg2 => меньше 0,
   arg1=arg2 => 0,
   arg1>arg2 => больше 0.

 ш1.2
   Массив сортируется в порядке возрастания, т.е. по самому младше-
му адресу будет записан наименьший элемент.
   Функция-параметр compare фактически определяет порядок,  исполь-
зуемый при  сортировке.  Задавая  с её помощью различные порядки на
сортируемом множестве, можно получить различные упорядочения исход-
ного массива.
   Например, чтобы отсортировать массив в порядке убывания (т.е. от
большего к меньшему),  необходимо в этой функции определить "обрат-
ный" порядок. Это можно сделать, например, так:
 ш1.0

   compare1(x,y)=compare(y,x).
 ш1.2

                       26. 0  3Сортировка слиянием
   В основе  _ 1сортировки слиянием . 0 лежит замечание,  согласно которому
слияние двух отсортированных списков выполняется быстро.
   Список из одного элемента уже отсортирован,  поэтому  сортировка
слиянием разбивает список на одноэлементные "куски", а затем после-
довательно выполняет их слияние.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 9, Пример 10.

 ш1.2
    3Замечание 0 [Романовский,2004,с.111].
 ш1.1
   Процедура слияния  настолько проста,  что иногда её проще не де-
лать заранее, а выполнять "на лету",  в ходе работы алгоритма,  ис-
пользующего результат  слияния.  Такой список,  создаваемый по мере
надобности, в программном отношении выглядит как обычный список.
   Программные объекты такого рода называются  _ 1виртуальными . 0.
 ш1.2

                  27.  3Алгоритм сортировки подсчётом

 ш1.0
               1Сколько ни перечислять всё то, что он знает, - сказал
               1я себе,  - невозможно догадаться,  для чего  ему  это
               1нужно  и  что  за профессия требует такого сочетания 0!
               1Нет, лучше уж не ломать себе голову понапрасну 0!
                                 1А.Конан Дойл. Этюд в багровых тонах
 ш1.2

   Вначале для  каждого  элемента массива подсчитывается количество
элементов, меньших,  чем он,  и на основе этой  информации  текущий
элемент помещается в соответствующее место отсортированного массива.
   Приведём алгоритм на  1псевдокоде 0 [Левитин,2006,с.52]:
 ш1.0

   // Сортировка массива методом подсчёта сравнений.
   // Входные данные: массив чисел A[0..n-1], который требуется
   //                 отсортировать.
   // Выходные данные: массив чисел S[0..n-1], состоящий из элемен-
   //                  тов массива A, отсортированных  в  неубываю-
   //                  щем порядке
   // ----------------------------
   for i:=0 to n-1 do
      Count[i]:=0
   for i:=0 to n-2 do
      for j:=i+1 to n-1 do
         if A[i]<A[j]
           Count[j]:=Count[j]+1
         else Count[i]:=Count[i]+1
   for i:=0 to n-1 do
      S[Count[i]]:=A[i]
   return S

 ш1.2
   Какова же временная эффективность данного алгоритма?
   Она должна  быть квадратичной,  поскольку алгоритм рассматривает
все различные пары n-элементного массива.  Более строго, количество
выполнений базовой операции сравнения A[i]<A[j] равно
 ш1.0

    5n-2 0   5n-1 0    5n-2 0               5n-2
    7░▒ 0    7░▒ 0     7░▒ 0                7░▒ 0          (n-1) 77 0n
     7▓  0    7▓ 0 1 =  7▓  0(n-1-(i+1)+1)=  7▓  0(n-1+i)= ───────  7еQ 0(n 52 0).
    7│┤ 0    7│┤ 0     7│┤ 0                7│┤ 0             2
    4i=0 j=i+1 0   4i=0 0               4i=0

 ш1.2
   Поскольку алгоритм  выполняет то же количество сравнений ключей,
что и алгоритм сортировки выбором, и при  этом  требуется  линейное
количество дополнительной  памяти,  его  трудно  рекомендовать  для
практического применения.
                  28. 0  3Алгоритм сортировка подсчётом
                            3распределения
   Однако идея  подсчёта хорошо работает в ситуации,  когда нам из-
вестны  1минимальный 0 элемент сортируемого массива (обозначим его  1l 0) и
 1максимальный 0 элемент сортируемого массива (обозначим его  1u 0).
   Элементы массива будем копировать в новый массив S[0..n-1].
   При этом те элементы A, значения ключей которых равны наименьше-
му возможному значению 1 l 0,  копируются в первые  F[0]  элементов  S,
т.е. в позиции от 0 до F[0]-1,  элементы со значением ключа  1l 0+1 - в
позиции от F[0] до F[0]+F[1]-1 и т.д. поскольку такие накапливаемые
суммы частот  в статистике называются  1распределением 0,  то описанный
метод называется  _ 1сортировкой подсчётом распределений . 0.
   Приведём алгоритм на псевдокоде [Левитин,2006,с.309-310]:
 ш1.0

   // Сортировка массива целых чисел из ограниченного диапазона
   // при помощи сортировки подсчётом распределения.
   // Входные данные: массив A[0..n-1] целых чисел, расположенных
   //                 между 1 l 0 и  1u 0 ( 1l 7, 1u 0).
   // Выходные данные: массив чисел S[0..n-1], состоящий из элемен-
   //                  тов массива A, отсортированных  в  неубываю-
   //                  щем порядке
   // ------------------------------------------------------
   for j:=0 to  1u 0- 1l 0 do        // Инициализация массива частот
      D[j]:=0
   for i:=0 to n-1 do        // Вычисление частот
      D[A[i]- 1l 0]:=D[A[i]- 1l 0]+1
   for j:=1 to  1u 0- 1l 0 do        // Получение распределения
      D[j]:=D[j-1]+D[j]
   for i:=n-1 downto 0 do
      j:=A[i]- 1l
      S[D[j]-1]:=A[i]
      D[j]:=D[j]-1
   return S

 ш1.2
   В предположении фиксированного диапазона значений очевидно,  что
этот алгоритм линеен, поскольку выполняет два последовательных про-
хода по  входному массиву A.  Эффективность этого алгоритма гораздо
выше, чем у таких алгоритмов сортировки,  как слиянием,  быстрой  и
пирамидальной. Однако важно помнить, что эта эффективность получена
благодаря конкретному виду входных  данных,  для  которых  работает
сортировка подсчётом  распределения  (помимо использования дополни-
тельной памяти).
                     29. 3 Пирамидальная сортировка
    1Самостоятельно 0 разберитесь в этом алгоритме...

                 3Временная эффективность 0  3алгоритмов
                         3сортировки 0  3массивов

 ш1.0
                      1... задача, стоящая перед программистом, - это
                      1интеллектуальный вызов высочайшего ранга.
                                                          1Э.Дейкстра
 ш1.2

   Вычислим временную эффективность некоторых алгоритмов сортировки
массивов.
   Учтите, что при анализе  1наихудшего варианта 0 оценивают максималь-
ный объём работы, необходимой для решения задачи заданного размера,
а при анализе  1среднего варианта 0 - вероятный объём работы.
    21. 0  _ 1Сортировка обменами . 0: количество сравнений
 ш1.0

    5n-2 0  5n-2-i
    7░▒ 0   7░▒ 0     (n-1) 77 0n
     7▓  0   7▓ 0 1 = ───────  7еQ 0(n 52 0).
    7│┤ 0   7│┤ 0        2
    4i=0 j=0

 ш1.2
   Количество обменов в наихудшем случае равно
 ш1.0

   (n-1) 77 0n
   ───────  7еQ 0(n 52 0).
      2

 ш1.2
    22. 0  _ 1Сортировка выбором . 0: количество сравнений
 ш1.0

    5n-2 0   5n-1
    7░▒ 0    7░▒ 0     (n-1) 77 0n
     7▓  0    7▓ 0 1 = ───────  7еQ 0(n 52 0).
    7│┤ 0    7│┤ 0        2
    4i=0 j=i+1

 ш1.2
    23. 0  _ 1Сортировка вставками . 0: количество сравнений в наихудшем случае
 ш1.0

    5n-1 0  5i-1
    7░▒ 0   7░▒ 0     (n-1) 77 0n
     7▓  0   7▓ 0 1 = ───────  7еQ 0(n 52 0).
    7│┤ 0   7│┤ 0        2
    4i=1 j=0

 ш1.2
   Для уже  отсортированного  массива  количество  сравнений  равно
n-1 7еQ 0(n), а при работе со  1случайными массивами 0  среднее  количество
сравнений равно n 52 0/4 7еQ 0(n 52 0).
   В таблице (см. [Каррано,Причард,2003,с.447]) показаны приближён-
ные  _ 1оценки сложности алгоритмов сортировки . 0 (в наихудшем и наилучшем
вариантах).
 ш1.0

                               ╓─────────────────┬───────────────┐
                               ║ 3Наихудший вариант 0│ 3Средний вариант 0│
  ┌─────────────────────────── 1─ 0╫─────────────────┼───────────────┤
  │ 1Сортировка обменами  0        1  0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка выбором           0║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка включениями 0      ║       7O 0(n 52 0)      │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Быстрая сортировка           0║       7O 0(n 52 0)      │   7O 0(n 77 1log 0(n))  │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка слиянием 0        1  0 ║     7O 0(n 77 1log 0(n))  │   7O 0(n 77 1log 0(n))  │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Пирамидальная сортировка 0   1  0 ║     7O 0(n 77 1log 0(n))  │   7O 0(n 77 1log 0(n))  │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка подсчётом 0        ║                 │      7O 0(n 52 0)     │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │ 1Сортировка подсчётом 0  1распре- 0║       7O 0(n)       │      7O 0(n)      │
  │ 1деления 0                     ║                 │               │
  ╞════════════════════════════╬═════════════════╪═══════════════╡
  │Поразрядная сортировка     1  0 ║       7O 0(n)       │      7O 0(n)      │
  ├────────────────────────────╫─────────────────┼───────────────┤
  │Сортировка с помощью дерева ║       7O 0(n 52 0)      │   7O 0(n 77 1log 0(n))  │
  └────────────────────────── 1─ 0─╨─────────────────┴───────────────┘

 ш1.2
    3Предупреждения 2  0[Каррано,Причард,2003,с.448].
 ш1.1
    21. 0 Если  размер  задачи  невелик,  не стоит вообще анализировать
сложность алгоритма.  В этом случае основным фактором является  его
 1простота 0. Так, для сортировки массива, содержащего не более 25 эле-
ментов вполне подходит простой алгоритм сортировки включениями, хо-
тя его сложность  7O 0(n 52 0).
    22. 0 При  сортировке  очень большого массива алгоритмы,  сложность
которых оценивается величиной  7O 0(n 52 0), не эффективны.
    23. 0 Алгоритм  быстрой  сортировки  следует выбирать,  только если
элементы массива расположены в произвольном порядке.
   Несмотря на то,  что в худшем случае сложность алгоритма быстрой
сортировки оценивается величиной  7O 0(n 52 0),  на практике такая ситуация
встречается крайне редко.
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
         1Донован услышал напряжённый голос Пауэлла:
         1- Теперь слушай.  Начнём с Трёх Основных Законов Роботехники
         1- трёх правил,  которые прочно закреплены в позитронном моз-
         1гу. Первое: робот не может причинить вред человеку или своим
         1бездействием допустить, чтобы человеку был причинён вред. 0
         1- Правильно.
         1- Второе,  -  продолжал Пауэлл,  - робот должен повиноваться
         1всем приказам,  которые даёт человек,  если эти  приказы  не
         1противоречат Первому Закону. 0
         1- Верно.
         1- И  третье:  робот должен заботиться о своей безопасности в
         1той мере,  в какой это не противоречит Первому 0  1и Второму За-
         1конам. 0
         1- Верно. Ну и что 0?
         1- Так это же всё объясняет. Когда эти законы вступают в про-
         1тиворечие между собой,  дело решает разность позитронных по-
         1тенциалов в мозгу. Что получается, если робот приближается к
         1месту,  где ему грозит опасность,  и сознаёт это? Потенциал,
         1который создаётся Третьим Законом,  автоматически заставляет
         1его вернуться.  Но представь себе, что ты приказал ему приб-
         1лизиться к опасному месту, В этом случае Второй Закон созда-
         1ёт противоположный потенциал,  который выше первого, и робот
         1выполняет приказ с риском для собственного существования. 0
                                                   1А.Азимов. Хоровод
 ш1.2

                      21. 3 Применение алгоритмов
                         3сортировки массивов
    21 4* 2. 0 Используя любой алгоритм сортировки, в числовом массиве 3  0най-
дите максимальный элемент.
    22 4* 2. 0 Используя любой алгоритм сортировки, в числовом массиве най-
дите элемент, ближайший к минимальному.
    23 4* 2. 0 Дан числовой массив. Напишите предикат, проверяющий, являет-
ся ли он упорядоченным по убыванию 2  0(возрастанию).
    24 4* 2. 0 Напишите  функцию  для нахождения  1медианы числового массива 0,
использующую следующий алгоритм:  вначале выполните сортировку мас-
сива, а затем выберите "средний" элемент.
 ш1.1
    _Указание ..  _ 1Медианой массива, содержащего . 4  1n  _элементов . 0,  называется
элемент,  значение которого меньше (или равно) половины n элементов
и больше (или равно) другой половины.
   Например, 22 является медианой массива 16,22,99,95,18,87,10.

 ш1.2
    25 5* 2. 0 Найдите  количество  различных чисел среди элементов данного
массива; число действий должно быть порядка n 77 1log 42 0n.
 ш1.1
    _Указание .. Отсортируйте массив,  а  затем  посчитайте  количество
различных элементов, просматривая элементы по порядку.

 ш1.2
                 22. 3 Реализация алгоритмов сортировки
    21. 0 (По [Поляков,Ерёмин,2013,ч.2,с.33-34])
   Напишите программу реализации алгоритма  _ 1сортировки подсчётом . 0.
    22. 0 (По [Макдауэлл,2012,с.77])
   Массив A[1..n] содержит целые числа от 0 до n, но одно число от-
сутствует. Элементы массива A хранятся в двоичном виде.
   Невозможно получить доступ к любому элементу в массиве A  с  по-
мощью  операции   1A 0[ 1i 0],  однако доступ к элементам можно осуществить
только при помощи команды " 1Извлечь j-й бит из A 0[ 1i 0]", имеющей фикси-
рованное время выполнения.
   Напишите код, обнаруживающий отсутствующее целое число.
   Можно ли выполнить эту задачу за время 7 O 0(n)?
    23. 0 Выполните  программную  реализацию алгоритма "блинной" сорти-
ровки.
    _ 1Указание . 0.
 ш1.1
   " _ 1Блинная . 0"  _ 1сортировка . 0 (англ.  1pancake sorting 0) - это алгоритм сор-
тировки, единственной операцией которого является переворот элемен-
тов  последовательности до какого-либо индекса.  В отличие от алго-
ритмов сортировки,  в которых минимизируют количество сравнений,  в
блинной сортировке требуется сделать как можно меньше переворотов.
   Процесс можно визуально представить как стопку  блинов,  которую
тасуют путём взятия нескольких блинов сверху и их переворачивания.

 ш1.2
    24 5* 2. 0 Выполните  программную  реализацию  алгоритма  пирамидальной
сортировки.
    25. 0 (По [Левитин,2006,с.310-311])
    _ 1Задача о Российском флаге . 0. Переставьте элементы массива символов
К, С,  Б,  означающих красный, синий и белый цвета флага, так чтобы
первыми шли символы Б, затем - С, а последними - К.
   Разработайте алгоритм,  решающий поставленную задачу за линейное
время без привлечения дополнительной памяти.
    26 5* 2. 0 (По [Шень,1995])
   Практически важный алгоритм сортировки таков:  чтобы  отсортиро-
вать массив,  выберем случайный его элемент b, и разобьём массив на
три части:  меньшие b, равные b и большие b. Теперь осталось отсор-
тировать первую и третью части: это делается тем же способом.
   Приведите рекурсивную реализацию этого алгоритма сортировки.
    3Замечание 0.
 ш1.1
   Время работы  этого алгоритма - случайная величина;  можно дока-
зать,  что в среднем он "работает" C 77 0n 77 1log 0(n)  единиц  времени  (на
практике - он один из самых быстрых).

 ш1.2
    27 5* 2. 0 Упорядочите целочисленный массив по неубыванию следующим  _ 1ме-
 _ 1тодом фон Неймана . 0. Сформируйте два массива A и B и поместите исход-
ный массив в A; упорядочите пары соседних чисел (A 41 0 и A 42 0, A 43 0 и A 44 0 и
т.д.) и запишите их в массив B; возьмите из массива B по две сосед-
ние упорядоченные пары и, "слив" их в упорядоченные четвёрки, снова
запишите в массив A; затем каждые две соседние четвёрки из B "слей-
те" в упорядоченные восьмёрки и перенесите в массив A и т.д.
    28 5* 2. 0 Опишите функцию, 4  0упорядочивающую по неубыванию  _ 1числовой . 0 мас-
сив x следующим методом:  все числа из x упорядочить  по   1последней
цифре  и  перенести  во вспомогательный массив y;  затем числа из y
упорядочить по  1предпоследней 0 цифре (при равенстве этих цифр  сохра-
нять упорядоченность по последней цифре) и записать их снова в спи-
сок x; далее числа из x упорядочить по  1третьей от конца 0 цифре и пе-
ренести в массив y и т.д.
   Учесть, что в конце концов числа должны оказаться в массиве.
    29 5* 2. 0 Докажите,  что следующий  1функционал 0 реализует сортировку за-
данного списка:
 ш1.0

   sortG :: (t -> t -> Bool) -> [t] -> [t]
   sortG comp []    = []
   sortG comp (a:x) = sortG comp sml ++ [a] ++ sortG comp lrg
       where sml = [b | b <- x, comp b a]
             lrg = [b | b <- x, comp a b]
   --------------------------------------
   test1 = sortG (>=) [4,3,5,2,6,1,2]
   test2 = sortG (<)  [4,3,5,2,6,5,5]

 ш1.2
    210. 0 Реализуйте  операцию  " 1соединение  двух  списков 0"  с помощью
функции, объединяющей элементы двух списков на основе тестов:
 ш1.0

   > merge (<) [2,4,6,8,10] [3,5,7,11]
   [2,3,4,5,6,7,8,10,11]

   > merge (<=) [2,4,6,8,10] [2,4,6,8]
   [2,2,4,4,6,6,8,8,10]

   > merge (=) [2,4,6] [3,5,7,11]
   [2,4,6,3,5,7,11]

 ш1.2
                       23. 0  3Контрольные задания
    21. 0 [Поляков,Ерёмин,2013,ч.2,с.34]
   Алфавит языка племени "тумба-юмба" содержит k символов.
   Предложите алгоритм  построения всех возможных слов этого языка,
имеющих длину n символов, и оцените его асимптотическую сложность.

    _ 1Домашнее задание . 0 (19.04-26.04.2019):
 ш1.0

   №№  21 41,2,4,5 0;  22 41,2 0 ( 16 задач 0).

    _ 1Дополнительные задачи . 0: №№ ...
 ш1.2
