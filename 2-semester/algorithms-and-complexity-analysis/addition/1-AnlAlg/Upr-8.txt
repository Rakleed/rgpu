    2ЛАБОРАТОРНАЯ РАБОТА 8.
    2КОНСТРУИРОВАНИЕ ОДНОПРОХОДНЫХ АЛГОРИТМОВ

 ш1.0
            1Простое - значит с минимальным математическим аппаратом.
            1Эффективное - значит с ясным физическим результатом. 0
                                                          1Л.Д.Ландау
 ш1.2

    _ 1Знать . 0  _ 1понятия . 0:
 ш1.0
    1- 0  1однопроходной алгоритм, индуктивная функция 0;
    1- 0  1индуктивное расширение.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
    1Построение алгоритмов 0 - это один из центральных элементов инфор-
матики, без которого не обходится ни один учебный курс. Но в школь-
ной  и  студенческой  практике  построение каждого нового алгоритма
часто рассматривается как самостоятельная творческая задача, в луч-
шем  случае  происходит освоение и накопление каких-то приёмов,  но
почти никогда дело не доходит до методов.
   Однако в информатике существуют методы, применение которых прев-
ращает трудную задачу,  требующую творческого озарения,  в  задачу,
решаемую стандартным путём. Эти методы и их теоретическое обоснова-
ние часто бывают сложны и требуют высокой математической  культуры,
поэтому они могут быть полезны в углублённых учебных курсах.
   Одним из таких методов является метод   _ 1построения  однопроходных
 _ 1алгоритмов на основе применения индуктивных функций . 0, который описан
в  работах  [Кушниренко,Лебедев,1988;  Зайдельман,1995;  Шень,1995;
Шень,2004].

                  3Понятие "однопроходный алгоритм"

 ш1.0
                 1Где начало того конца, которым оканчивается начало 0?
                                                      1Козьма Прутков
 ш1.2

   В практике  профессионального  программирования  часто возникают
задачи, в которых необходимо  определить  некоторые  характеристики
последовательности входных данных. Для решения подобных задач необ-
ходимо организовать просмотр (перебор) всех входных элементов.
    2Определение 0 (по [Кушниренко,1988,с.131]).
 ш1.1
    2(1) 0  _ 1Проходом . 0  ( 1в  программировании 0) называется перебор ("посеще-
ние") всех элементов последовательности.
    2(2) 0 Алгоритмы  работы с последовательностями принято классифици-
ровать по числу проходов и называть  _ 1однопроходными . 0,   _ 1двухпроходными
и т.д.  _ 1алгоритмами . 0.
    2(3) 0  _ 1Однопроходным алгоритмом . 0 называется алгоритм, который  1после-
 1довательно 0  "читает" элементы входной последовательности (по одному
разу) от её начала к её концу.

 ш1.2
   Важно отметить, что  одну и ту же задачу можно решить за  разное
количество проходов.
   Понятно, что  однопроходный  алгоритм эффективнее,  особенно для
длинных последовательностей, а в некоторых ситуациях другие решения
просто неприменимы. Например, если входная последовательность - это
показания какого-то датчика,  то хранить результаты всех  измерений
невозможно  (их слишком много),  но необходимо в любой момент выда-
вать сводные характеристики (например,  максимальное и среднее зна-
чения).  Поэтому  единственным выходом является построение однопро-
ходного алгоритма обработки входных данных.
                    3Понятие "индуктивная функция"
   Пусть M - некоторое множество.
    2Определение 0 [Шень,2004,с.37].
 ш1.1
   Функция  3f 0,  аргументами которой являются последовательности эле-
ментов множества M, а значениями - элементы некоторого множества N,
называется  _ 1индуктивной функцией . 0, если её значение на последователь-
ности <x[1],...,x[n]> можно восстановить по её значению на последо-
вательности <x[1],...,x[n-1]> и по x[n], т.е. если  _ 1существует . 0 функ-
ция F:N 7& 0M─ 76 0N, для которой
 ш1.0

     4┌ 0                4┐ 0   4┌ 0                          4┐
    3f 0│<x[1],...,x[n]>│=F│ 3f 0(<x[1],...,x[n-1]>),x[n]│.
     4└ 0                4┘ 0   4└ 0                          4┘

 ш1.2
    _ 1Алгоритм вычисления значения индуктивной функции . 0
   [Шень,2004,с.38].
 ш1.1

   f:=f0; { f0 - значение функции на  1пустой последовательности 0 }
          { (последовательности длины 0)                       }
   k:=0;
   While k<>n do
     begin k:=k+1; f:=F(f,x[k]) end;

 ш1.2
   Если функция f определена только на  непустых  последовательнос-
тях, то схема алгоритма вычисления индуктивной функции такова:
 ш1.0

   f:=f(<x[1]>);
   k:=1;
   While k<>n do
     begin k:=k+1; f:=F(f,x[k]) end;
 ш1.2
                       3Критерий индуктивности
   Для установления  индуктивности интересующей нас функции,  можно
применить следующий
    _ 1Критерий индуктивности . 0 [Зайдельман,1995,с.97].
 ш1.1
   Для того,  чтобы функция являлась индуктивной,  1необходимо и дос-
 1таточно 0, чтобы выполнялось следующее условие: если значение функции
одинаково для двух  1несовпадающих 0 последовательностей,  то оно оста-
нется одинаковым при любом совпадающем продолжении этих  последова-
тельностей.

 ш1.2
   На практике это означает, что значение индуктивной функции после
добавления нового  элемента можно вычислить по предыдущему значению
функции и значению нового элемента, не зная всех предыдущих элемен-
тов входной последовательности (мы почти дословно повторили опреде-
ление понятие " 1индуктивная функция 0").
   Например, сумма  элементов последовательности получается прибав-
лением нового элемента к предыдущей сумме,  независимо от того,  из
каких слагаемых эта предыдущая сумма была составлена.
    2Пример 0 ( 1функции, не являющейся индуктивной 0).
 ш1.1
   Функция " 1количество  максимальных  элементов последовательности 0"
не является индуктивной. Интуитивно это очевидно (количество макси-
мумов  нельзя  определить по прежнему количеству и новому элементу,
т.к. этих данных недостаточно,  чтобы установить, является ли новый
элемент максимальным).
   Получим с помощью критерия индуктивности строгое доказательство.
   В самом деле, рассмотрим две последовательности:
 ш1.0

   X1={2}, X2={5}.

 ш1.1
   Количество максимумов в обеих последовательностях равно 1. Доба-
вим в каждую последовательность новый элемент, равный 2. Количество
максимумов в первой последовательности станет равным 2,  во  второй
останется равным 1. Одинаковое продолжение привело к разным резуль-
татам, следовательно, по критерию индуктивности функция не является
индуктивной.

 ш1.2
                  3Понятие "индуктивное расширение"
   Если функция f не является индуктивной,  то можно искать её   _ 1ин-
 _ 1дуктивное расширение . 0.
    2Определение 0 (по [Шень,2004,с.38]).
 ш1.1
    _ 1Индуктивным расширением функции . f 0 называется  1индуктивная функция
 1g 0,  значения которой определяют значения функции f, т.е.  1существует
такая функция t, что для всех <x[1]...x[n]>
 ш1.0

     4┌ 0              4┐ 0   4┌ 0  4┌ 0              4┐┐
    3f 0│<x[1]...x[n]>│=t│ 3g 0│<x[1]...x[n]>││.
     4└ 0              4┘ 0  7% 4└ 7% 4└ 0              4┘┘
                    │  4└ 0──── 1 Индуктивная функция  0( 1индуктивное
                    │                             1расширение f 0)
                     4└ 0────── 1 Произвольная функция

 ш1.2
    2Теорема 0 ( 1А.Г.Кушниренко 0).
 ш1.1
   Среди всех индуктивных расширений существует  1минимальное  расши-
 1рение 0 f (минимальность означает, что для любого индуктивного расши-
рения g значения f определяются значениями g).

 ш1.2
                  3Векторное индуктивное расширение
   На практике чаще всего применяют  _ 1векторные индуктивные  расшире-
 _ 1ния . 0, т.е.  рассматривают несколько функций,  индуктивных в совокуп-
ности. Это означает,  что новое значение всех этих функций при  до-
бавлении в последовательность одного элемента можно получить,  зная
предыдущие значения этих функций и  добавленный  элемент.  Одна  из
этих функций  1обычно 0 является искомой.
   На практике  индуктивное вычисление функции на пространстве пос-
ледовательностей сводится  обычно  к применению одного из следующих
двух приёмов [Кушниренко,Лебедев,1988,с.122].
    _ 1Первый приём . 0 состоит в представлении неиндуктивной функции в ви-
де композиции индуктивных функций.
   Например, функцию  " 1среднее  арифметическое элементов последова-
 1тельности 0" можно представить в  виде  композиции  двух  индуктивных
функций
 ш1.0

    7S 0 / n,

 ш1.2
где  7S 0 - сумма, n - число элементов последовательности.
   Если это удаётся,  то в качестве индуктивного  расширения  можно
взять  объединение  полученных  индуктивных  функций  (для среднего
арифметического - пару ( 7S 0,n)).
   Разложение функции в композицию индуктивных функций, однако, яв-
ляется   1творческой задачей 0 (!)  и потому применяется только в прос-
тейших случаях, где такое разложение более или менее очевидно.
    _ 1Второй приём . 0  состоит в выражении значения f(w*x) через значения
f(w) и  x.  Здесь * - знак операции,  добавляющей элемент x к концу
последовательности w.
   После этого необходимо посмотреть,  какой информации, кроме f(w)
и x, не хватает для вычисления f(w*x).
   Пусть эта информация выразима в виде f 41 0(w).
   Если f 41 0(w*x) выражается через f(w), f 41 0(w) и x, то в качестве ин-
дуктивного расширения можно взять пару (f,f 41 0).
   В противном  случае  недостающая информация обозначается f 42 0(w) и
рассматривается f 42 0(w*x). И опять, если f 42 0(w*x) выражается через x и
функции f(w), f 41 0(w) и f 42 0(w), то тройка (f,f 41 0,f 42 0) является индуктив-
ным расширением f.
   В противном случае рассматривается недостающая информация  f 43 0  и
т.д. до тех пор, пока не будет получено индуктивное расширение f.
   Второй приём,  в отличие от первого, является регулярным и почти
не требует творческих усилий. Ниже мы в основном будем пользоваться
именно вторым приёмом - добавлением к функции информации, недостаю-
щей для её индуктивности.
    2Выводы 0 ( 1важные 0) [Зайдельман,1995,с.101].
 ш1.1
    21. 0 Использование однопроходных алгоритмов даёт выигрыш во  1време-
 1ни 0.
    22. 0 За  этот выигрыш приходится платить  1памятью 0,  необходимой для
хранения индуктивного расширения.  В тех случаях, когда размер этой
памяти сопоставим с размером исходной последовательности, построить
 1подлинно однопроходный алгоритм 0 не всегда удаётся.

 ш1.2
               3Элементарные операции, используемые при
               3моделировании однопроходных алгоритмов
   Для моделирования  однопроходных  алгоритмов удобно использовать
следующие  _ 1элементарные операции . 0 (по [Непейвода,2001,с.85]):
   (1)  1одноместную  операцию 0  1Tail 0(x),  выделяющую последний элемент
непустого кортежа х:
 ш1.0

        4┌ 0            4┐
    1Tail 0│<a 41 0,...,a 4n 0>│ 7" 0a 4n 0;
        4└ 0            4┘

 ш1.2
   (2)  1одноместную операцию 0  1Body 0(x), удаляющую из непустого кортежа
его последний элемент:
 ш1.0

        4┌ 0            4┐
    1Body 0│<a 41 0,...,a 4n 0>│ 7" 0<a 41 0,...,a 4n-1 0>;
        4└ 0            4┘

 ш1.2
   (3) двухместную операцию  1AppendTail 0(),  добавляющую второй аргу-
мент в конец первого аргумента, являющегося кортежем:
 ш1.0

              4┌ 0                 4┐
    1AppendTail 0│<a 41 0,...,a 4n-1 0>,a 4n 0│ 7" 0<a 41 0,...,a 4n-1 0,a 4n 0>.
              4└ 0                 4┘

 ш1.2
                3Работа с демонстрационными примерами
   См. Пример 1, Пример 2.

             2ПРИМЕРЫ РЕШЕНИЯ НЕКОТОРЫХ ТИПОВ УПРАЖНЕНИЙ

 ш1.0
                  1... профессионал в любом деле должен иметь в своём
                  1распоряжении около 20000 конкретных примеров. 0
                                                              1П.Дойч
 ш1.2

    2Пример 1. 0  Установите,  является ли функция " 1сумма  всех  членов
 1последовательности 0"  1sum 0() индуктивной функцией.
    _ 1Решение . 0.
 ш1.0

       4┌ 0                4┐ 0     4┌ 0                  4┐
    1sum 0│<x[1],...,x[n]>│= 1sum 0│<x[1],...,x[n-1]>│+x[n].
       4└ 0                4┘ 0     4└ 0                  4┘

   Запишем "сказанное" в постфиксной форме:

       4┌ 0                4┐ 0   4┌ 0    4┌ 0                  4┐ 0      4┐
    1sum 0│<x[1],...,x[n]>│=+│ 1sum 0│<x[1],...,x[n-1]>│,x[n]│.
       4└ 0                4┘ 0   4└ 0    4└ 0                  4┘ 0      4┘

 ш1.2
   Таким образом, функция  1sum 0() является индуктивной и индуктивного
расширения не требуется.
   Приведём соответствующую функцию на языке Haskell:
 ш1.0

   sum1:: [Integer] -> Integer
   sum1 lst | null lst        = error ""
            | null (tail lst) = head lst
            | True            = head lst + sum (tail lst)
   ------------------------------------------------------
   -- Неудачные тестовые примеры:
   ---------------------------------------------------
   test1 = sum1 [1,1,1,1]                        ==  4
   test2 = sum1 [1,2,3,4]                        == 10
   test3 = sum1 [1,1,1,1,2,2,2,2,2]              == 14
   test4 = sum1 [2,1,1,1,1,3,3,3]                == 15
   test5 = sum1 (replicate 4 5 ++ replicate 7 3) == 41

 ш1.2
   Однако реализованная функция sum1 не обладает "хвостовой" рекур-
сией, для  организации которой приходится воспользоваться индуктив-
ным расширением. Приведём функцию на языке Haskell:
 ш1.0

   sum2:: [Integer] -> Integer -> Integer
   sum2 lst res | null lst        = error ""
                | null (tail lst) = res+head lst
                | True            = sum2 (tail lst) (res+head lst)
   ---------------------------------------------------------------
   -- Неудачные тестовые примеры:
   -----------------------------------------------------
   test1 = sum2 [1,1,1,1] 0                        ==  4
   test2 = sum2 [1,2,3,4] 0                        == 10
   test3 = sum2 [1,1,1,1,2,2,2,2,2] 0              == 14
   test4 = sum2 [2,1,1,1,1,3,3,3] 0                == 15
   test5 = sum2 (replicate 4 5 ++ replicate 7 3) 0 == 41
 ш1.2

    2Пример 2. 0  Установите, является ли функция " 1длина последователь-
 1ности 0"  1Length 0() индуктивной функцией.
    _ 1Решение . 0.
 ш1.0

          4┌ 0                4┐ 0        4┌ 0                  4┐
    1Length 0│<x[1],...,x[n]>│= 1Length 0│<x[1],...,x[n-1]>│+1=
          4└ 0                4┘ 0        4└ 0                  4┘
                             4┌ 0       4┌ 0                  4┐ 0   4┐
                          =+│ 1Length 0│<x[1],...,x[n-1]>│,1│.
                             4└ 0       4└ 0                  4┘ 0   4┘

 ш1.2
   Таким образом, функция  1Length 0() является индуктивной и индуктив-
ного расширения не требуется.
   Однако реализованная функция sum1 не обладает "хвостовой" рекур-
сией, для  организации которой приходится воспользоваться индуктив-
ным расширением.

    2Пример 3. 0 [Зайдельман,1995,с.98]  Найдите  максимальный  элемент
последовательности.
    _ 1Решение . 0. Пусть максимальный элемент последовательности  X  равен
m(X). При добавлении к последовательности элемента x получаем
 ш1.0

   m(X,x)= 1max 0(m(X),x).

 ш1.2
   Следовательно, искомая функция индуктивна.
   Запишем алгоритм  вычисления значения функции на непустой после-
довательности:
 ш1.0

   x:=Первый элемент;
   m:=x;
   While  1Не конец последовательности
     begin x:=Очередной элемент; m:= 1max 0(m,x) end

 ш1.2
    3Замечание 0.
 ш1.1
   На пустой последовательности значение функции не определено, по-
этому первый элемент последовательности приходится обрабатывать от-
дельно.

 ш1.2
   На языке  программирования  Haskell алгоритм вычисления значения
функции выглядит так:
 ш1.0

   -- Функция возвращает максимальный элемент
   -- одноуровневого числового списка lst
   --------------------------------------
   max1:: [Integer] -> Integer
   max1 lst | null lst        = error ""
            | null (tail lst) = head lst
            | True            = max (head lst) (max1 (tail lst))
   -------------------------------------------------------------
   -- Неудачные тестовые примеры:
   --------------------------------------------------
   test1 = max1 [1,1,1,1]                        == 1
   test2 = max1 [1,2,3,4]                        == 4
   test3 = max1 [1,1,1,1,2,2,2,2,2]              == 2
   test4 = max1 (replicate 4 5 ++ replicate 7 3) == 5
 ш1.2

    2Пример 4. 0 [Зайдельман,1995,с.99] Найдите количество максимальных
элементов последовательности.
    _ 1Решение . 0. Пусть n(X) - количество максимальных элементов в после-
довательности X.  Добавим к последовательности элемент x и  посмот-
рим, как изменится n. Очевидно, что
 ш1.0

           7( 01, при x>m(X);
          │
   n(X,x)= 7* 0n(X)+1, при x=m(X);
          │
           79 0n(X), при x<m(X).

 ш1.2
   Здесь m(X) - максимальный элемент последовательности X.
   Итак, функция  n(X) не является индуктивной,  но мы выделили до-
полнительную информацию,  необходимую для её вычисления, - это мак-
симальный элемент последовательности.  Функция m(X) индуктивна (по-
чему?), следовательно индуктивное расширение найдено.
   Приведём соответствующую функцию на языке Haskell:
 ш1.0

   lup1:: [Integer] -> Integer -> Integer -> Integer
   lup1 lst max res | null lst = error ""
                    | null (tail lst) 
                              = res
                    | head (tail lst)>max
                              = lup1 (tail lst) (head (tail lst)) 1
                    | head (tail lst)<max
                              = lup1 (tail lst) max res
                    | True    = lup1 (tail lst) max (res+1)
   --------------------------------------------------------
   -- Неудачные тестовые примеры:
   ------------------------------------------------------
   test1 = lup1 [1,1,1,1] 1 1                        == 4
   test2 = lup1 [1,2,3,4] 1 1                        == 1
   test3 = lup1 [1,2,2,1] 1 1                        == 2
   test4 = lup1 [1,1,1,1,2,2,2,2,2] 1 1              == 5
   test5 = lup1 [2,1,1,1,1,3,3,3] 1 1                == 3
   test6 = lup1 [4,4,4,1,1,1,1,1,1,1,1,1,1,5] 1 1    == 1
   test7 = lup1 (replicate 4 5 ++ replicate 7 3) 1 1 == 3
 ш1.2

    2Пример 5. 0 [Зайдельман,1995,с.99]  Найдите  длину  самой  большой
группы  _ 1подряд идущих . 0 одинаковых элементов последовательности.
    _ 1Решение . 0. Пусть  известна длина наибольшей постоянной подпоследо-
вательности (будем называть такие подпоследовательности   _ 1равнинами . 0)
в последовательности X.  Посмотрим, что может измениться при добав-
лении одного элемента.  Ясно, что если при этом появилась новая са-
мая длинная равнина, то она включает новый элемент. Получаем
 ш1.0

   lmax(X,x)= 1max 0(lmax(X),lx(X,x)),

 ш1.2
где lmax - длина максимальной равнины, lx - длина максимальной рав-
нины, заканчивающейся последним элементом последовательности.
   Итак, в индуктивное расширение для lmax надо включить lx.
   Вычислим lx. При добавлении нового элемента он либо начинает но-
вую равнину, либо продолжает предыдущую:
 ш1.0

            7( 01, если x 7- 0last(X);
   lx(X,x)= 7*
            79 0lx(X)+1, если x=last(X).

 ш1.2
   Здесь last(X) - последний элемент X.
   Очевидно, что last(X) является индуктивной функцией, т.к.
 ш1.0

   last(X,x)=x.

 ш1.2
   Индуктивное расширение получено; оно включает функции lmax, lx и
last. Теперь запишем алгоритм на псевдоязыке:
 ш1.0

   x:=Первый элемент;
   lmax:=1; lx:=1; last:=x;
   While  1Не конец последовательности
     begin
       x:=Очередной элемент;
       If x=last
         then lx:=lx+1
         else lx:=1;
       lmax:= 1max 0(lmax,lx); last:=x
     end

 ш1.2
   Приведём рекурсивную функцию на языке Haskell:
 ш1.0

   lup:: [Integer] -> Integer -> Integer -> Integer
   lup lst tek res | null lst = error ""
                   | null (tail lst) 
                              = max tek res
                   | head lst==head (tail lst)
                              = lup (tail lst) (tek + 1) res
                   | True     = lup (tail lst) 1 (max tek res)
   -----------------------------------------------------------
   -- Неудачные тестовые примеры:
   ------------------------------------------------------
   test1 = lup [1,1,1,1] 1 1                        ==  4
   test2 = lup [1,2,3,4] 1 1                        ==  1
   test3 = lup [1,2,2,1] 1 1                        ==  2
   test4 = lup [1,1,1,1,2,2,2,2,2] 1 1              ==  5
   test5 = lup [2,1,1,1,1,3,3,3] 1 1                ==  4
   test6 = lup [4,4,4,1,1,1,1,1,1,1,1,1,1,5] 1 1    == 10
   test7 = lup (replicate 4 5 ++ replicate 7 3) 1 1 ==  7
 ш1.2

    2Пример 6. 0 [Зайдельман,1995,с.99-100] Найдите  наибольшую   длину
монотонного участка последовательности.
    _ 1Решение . 0. Рассмотрим, как изменяется искомая функция при добавле-
нии к последовательности нового элемента.  Если при этом появляется
новый лучший участок, он обязательно включает новый элемент.
 ш1.0

   lmax(X,x)= 1max 0(lmax(X),lx(X,x)).

 ш1.2
   Монотонная последовательность может быть возрастающей и  убываю-
щей (правильнее было бы сказать, невозрастающей и неубывающей, т.к.
мы рассматриваем  нестрогую  монотонность).  Каждый  элемент  можно
рассматривать  как  завершение  двух монотонных рядов и выбирать из
них лучший.
 ш1.0

   lmax(X,x)= 1max 0(lup(X,x),ldown(X,x)).

 ш1.2
   Вычислим lup и ldown.  Если новый элемент больше предыдущего, он
увеличивает на единицу длину возрастающего участка и начинает новый
убывающий,  если  меньше - наоборот.  Элемент,  равный предыдущему,
увеличивает длину монотонных участков обоих направлений.
   Следовательно, для вычисления lup и ldown кроме предыдущего зна-
чения этих функций и нового элемента необходимо и достаточно знание
последнего элемента X,  а это,  как мы уже знаем, индуктивная функ-
ция. Итак, в индуктивное расширение входят функции
 ш1.0

   lmax, lx, lup, ldown, last.

 ш1.2
   Функцию lx можно исключить,  выразив lmax непосредственно  через
функции lup и ldown.
   Окончательное индуктивное расширение таково:
 ш1.1
   (1) длина наибольшего монотонного участка;
   (2) длина наибольшего невозрастающего участка,  включающего пос-
ледний элемент;
   (3) длина наибольшего неубывающего участка,  включающего послед-
ний элемент;
   (4) последний элемент.
 ш1.0

   x:=Первый элемент;
   lmax:=1; lup:=1; ldown:=1; last:=x;
   While  1Не конец последовательности
     begin
       x:=Очередной элемент;
       Выбор
       │ при x>last: lup:=lup+1; ldown:=1
       │ при x<last: lup:=1;     ldown:=ldown+1
       │ при x=last: lup:=lup+1; ldown:=ldown+1
       всё;
       lmax:=max(lmax,lup,ldown); last:=x
     end
 ш1.2

    2Пример 7. 0 [Зайдельман,1995,с.100]
   Для заданного x вычислите значение многочлена
 ш1.0

   a 40 0x 5n 0+a 41 0x 5n-1 0+ 7777 0+a 4n-1 0x+a 4n 0.

 ш1.2
   Элементы a 40 0,a 41 0,...,a 4n-1 0,a 4n 0  образуют последовательность,  причём
количество их заранее неизвестно.
    _ 1Решение . 0. Пусть известно значение многочлена P для некоторой пос-
ледовательности  коэффициентов  A.  При  добавлении нового элемента
степень всех предыдущих членов увеличивается на 1,  а новый элемент
становится свободным членом. Получаем, что
 ш1.0

   P(A,a)=xP(A)+a,

т.е. искомая функция индуктивна.

   P:=0;
   While  1Не конец последовательности
     begin a:=Очередной элемент; P:=x*P+a end

 ш1.2
    3Замечание 0.
 ш1.1
   Построен алгоритм, который называется  1схемой Горнера 0.
 ш1.2

    2Пример 8. 0 [Зайдельман,1995,с.100] Найдите наибольшую  сумму  не-
прерывного участка последовательности.
    _ 1Решение . 0. Пусть для последовательности X известна наибольшая сум-
ма S.  Что изменится при добавлении последнего элемента?  Если наи-
лучшая сумма изменится, то новый участок с лучшей суммой обязатель-
но будет включать вновь добавленный элемент:
 ш1.0

   S(X,x)= 1max 0(S(X),sx(X,x)),

 ш1.2
где sx - наибольшая сумма участка,  включающего  последний  элемент
последовательности.
   Как изменится sx при добавлении нового  элемента?  Возможны  два
случая: новый  элемент  включается в предыдущий участок с наилучшей
суммой или начинает новый участок:
 ш1.0

   S(X,x)= 1max 0(sx(X)+x,x).

 ш1.2
   Таким образом,  функции S и sx индуктивны в совокупности и обра-
зуют требуемое индуктивное расширение.
 ш1.0

   x:=Первый элемент;
   S:=x; sx:=x
   While  1Не конец последовательности
     begin
       x:=Очередной элемент; sx:= 1max 0(sx+x,x); S:= 1max 0(S,sx)
     end
 ш1.2

    2Пример 9. 0  Найдите  номер  первого  элемента последовательности,
равного данному.
    _ 1Решение . 0.  _Первый способ ..
   Индуктивно определим функцию  1Num 0:A 5* 7&N&N 0─ 76N 0 следующим образом:
 ш1.0

               7($ 0, если  7a 0= 7L 0;
              │
    1Num 0( 7a 0,x,n) 7"* 0n+1, если x=Head( 7a 0);
               72
               79 1Num 0(Tail( 7a 0),x,n+1), если x 7- 0Head( 7a 0).

 ш1.2
   Реализуем описанную функцию на языке LISP:
 ш1.0

   (DEFUN Num (LAMBDA (LST x n)
     (COND ( (NULL LST) 10000)
           ( (NEQ (CAR LST) x) (Num (CDR LST) x (+ n 1)) )
           (  T  (+ n 1) ))
   ))

 ш1.2
    _Второй способ .. Индуктивно определим функцию  1Num 0:A 5* 7&N 0─ 76N 0:
 ш1.0

             7($ 0, если  7a 0= 7L 0;
            │
    1Num 0( 7a 0,x) 7"* 0Length( 7a 0), если x=Head( 7a 0);
             72
             79 1Num 0(Tail( 7a 0),x), если x 7- 0Head( 7a 0).

 ш1.2
   Реализуем описанную функцию на языке LISP:
 ш1.0

   (DEFUN Main (LAMBDA (LST x)
      (+ 1 (- (LENGTH LST) (Num LST x)))
   ))
   ; ------------------------
   (DEFUN Num (LAMBDA (LST x)
     (COND ( (NULL LST) 10000)
           ( (NEQ (CAR LST) x) (Num (CDR LST) x) )
           (  T  (LENGTH LST) ))
   ))
 ш1.2

    2Пример 10. 0  Функция " 1среднее арифметическое элементов последова-
 1тельности 0" не является индуктивной функцией:  если мы знаем среднее
арифметическое последовательности,  но не знаем её длины, то не мо-
жем предсказать,  каким станет среднее арифметическое после дописы-
вания некоторого (известного нам числа).
   Для неиндуктивной функции " 1среднее арифметическое 0" возможным ин-
дуктивным расширением будет такое:
 ш1.0

   <Сумма элементов; Количество элементов>.

 ш1.2
   Искомая функция не входит в вектор индуктивного  расширения,  но
легко вычисляется по нему:
 ш1.0

   Среднее = Сумма / Количество.
 ш1.2

    2Пример 11. 0  Найдите элемент 7  0последовательности, наиболее близкий
к среднему арифметическому всей последовательности.
    _ 1Решение . 0. В данном случае   _ 1построить  однопроходной  алгоритм  не
 _ 1удаётся . 0,  т.к. добавление к этой последовательности нового элемента
может изменить среднее значение,  поэтому  1второй проход  становится
 1неизбежным 0.  В итоге приходится хранить все элементы последователь-
ности.
   Конечно, полученный алгоритм можно рассматривать как однопроход-
ный в том смысле, что он не требует повторного ввода, но в действи-
тельности алгоритм является  _ 1двухпроходным . 0.
   Программу для решения задачи напишите самостоятельно.

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 1.
 ш1.0

   ; Демонстрация моделирования функций Tail(), Body(),
   ; AppendTail() на языке программирования LISP
   ; -------------------------------------------
   (DEFUN Tail (LAMBDA (LST)
   ; Функция, возвращающая "хвост" списка LST
   ; ----------------------------------------
      (CAR (REVERSE LST))
   ))
   ; -----------------------
   (DEFUN Body (LAMBDA (LST)
   ; Функция, возвращающая "бесхвостое тело" списка LST
   ; --------------------------------------------------
      (REVERSE (CDR (REVERSE LST)))
   ))
   ; -------------------------------
   (DEFUN AppendTail (LAMBDA (LST a)
   ; Функция, добавляющая к концу списка LST элемент a
   ; -------------------------------------------------
      (REVERSE (CONS a (REVERSE LST)))
   ))
   ; -----------------------
   (DEFUN Car1 (LAMBDA (LST)
   ; Функция, моделирующая базовую функцию CAR на языке LISP
   ; -------------------------------------------------------
      (COND ( (NULL LST) NIL)
            ( (NULL (Body LST)) (Tail LST) )
            (  T  (Car1 (Body LST)) ))
   ))
   ; -----------------------
   (DEFUN Cdr1 (LAMBDA (LST)
   ; Функция, моделирующая базовую функцию CDR на языке LISP
   ; -------------------------------------------------------
      (COND ( (NULL LST) NIL)
            ( (NULL (Body LST)) NIL )
            (  T  (APPEND (Cdr1 (Body LST)) (LIST (Tail LST))) ))
   ))
   (RDS)
 ш1.2

    2Пример 2.
 ш1.0

   -- Демонстрация моделирования функций Tail(), Body(),
   -- AppendTail() на языке Haskell
   --------------------------------
   lst1 = [1,2,3,4,5]; lst2 = [10]
   test1 = last lst1
   test2 = init lst1
   test3 = init lst1 ++ lst2
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                    1Если вам плохо, крепко обнимите кота. Вот и всё.
                    1Теперь плохо не только вам, но и коту. 0
                                                    1Автор неизвестен
 ш1.2

                      21. 3 "Непрерывные" участки
                         3последовательностей
    21 4* 2. 0 [Зайдельман,1995]
   Напишите однопроходный  алгоритм (если это возможно;  если - не-
возможно, то постройте  1индуктивное расширение 0) для нахождения:
 ш1.1
   (1) суммы элементов последовательности;
   (2) максимального элемента последовательности;
   (3) количества максимальных элементов последовательности;
   (4) длины самой большой группы подряд идущих одинаковых  элемен-
тов последовательности;
   (5) наибольшей длины монотонного участка последовательности;
   (6) значения многочлена
 ш1.0

   a 40 77 0x 5n 0 + a 41 77 0x 5n-1 0 + 7777 0+ a 4n-1 77 0x + a 4n

 ш1.1
для заданного x;  коэффициенты a 40 0,a 41 0,...,a 4n 0 образуют последователь-
ность, количество элементов которой заранее неизвестно;
   (7) наибольшей суммы непрерывного участка последовательности.
   (8) наибольшего произведения непрерывного участка последователь-
ности.

 ш1.2
    22. 0 (По [Кушниренко,1988,с.134-135; Зайдельман,1995])
   Напишите однопроходной алгоритм (если это возможно;  если -  не-
возможно, то постройте индуктивное расширение), определяющий:
 ш1.1
   (1) произведение элементов последовательности;
   (2) сумму квадратов отрицательных элементов последовательности;
   (3) последний элемент последовательности;
   (4) минимальный элемент последовательности;
   (5) минимальный и максимальный элементы последовательности;
   (6) количество вхождений данного элемента в последовательность;
   (7) три наибольших элемента последовательности;
   (8) количество вхождений в последовательность элемента,  который
встречается в этой последовательности максимальное число раз;
   (9) 5* 0 число  вхождений  1подпоследовательности 0 p 41 0,p 42 0,...,p 4k 0 (все p 4i
различны) в данную последовательность;
   (10) число элементов последовательности,  удовлетворяющих преди-
кату Q(x);
   (11) число пар соседних элементов последовательности, удовлетво-
ряющих предикату Q(x 41 0,x 42 0);
   (12) возрастает ли данная последовательность;
   (13) равны ли все элементы последовательности между собой;
   (14) номер  первого  элемента,  имеющего максимальное значение в
последовательности;
   (15) номер  последнего элемента последовательности,  равного за-
данному элементу;
   (16) число  элементов числовой последовательности,  больших всех
предыдущих элементов последовательности;
   (17) число  1локальных максимумов 0 в данной последовательности.
    _ 1Локальным максимумом . 0 называется  элемент  последовательности,  у
которого нет соседа большего, чем сам элемент.
   Например, в любой одноэлементной  последовательности  содержится
один локальный максимум;
   (18) десятичное  значение  числа,  заданного последовательностью
его двоичных цифр;
   (19) значение производной,  записанного по возрастающим степеням
многочлена, заданного последовательностью коэффициентов;
   (20) значение k-ой производной,  записанного по убывающим степе-
ням многочлена, заданного последовательностью коэффициентов;
   (21) среднюю длину  1связной 0 (!) постоянной  подпоследовательности
данной последовательности;
   (22) среднюю длину  1связной 0 (!) возрастающей подпоследовательнос-
ти данной последовательности;
   (23) среднюю длину  1связной 0 (!) группы нулей в двоичной  последо-
вательности, состоящей из 0 или 1;
   (24) среднюю длину  1связной 0 (!) группы нулей в  последовательнос-
ти;
   (25) среднюю длину идентификатора в последовательности идентифи-
каторов;
   (26) наибольший  общий  делитель  элементов  последовательности,
элементами которой являются натуральные числа;
   (27) самый длинный  1пилообразный участок последовательности 0.
    _ 1Пилообразным участком последовательности . 0 называется  участок,  в
котором каждый элемент либо больше, либо меньше соседей;
   (28) количество различных элементов последовательности.

 ш1.2
    23. 0 [Шень,2004,с.38-39,№1.3.1]
   Укажите индуктивные расширения для следующих функций:
 ш1.1
   (а) среднее  арифметическое  последовательности вещественных чи-
сел;
   (б) число элементов последовательности целых  чисел,  равных  её
максимальному элементу;
   (в) второй по величине элемент  последовательности  целых  чисел
(тот,  который  будет вторым,  если переставить члены в неубывающем
порядке);
   (г) максимальное число идущих подряд одинаковых элементов;
   (д) максимальная длина монотонного (неубывающего или невозраста-
ющего) участка из  1идущих подряд 0 (!) элементов в  последовательности
целых чисел;
   (е) число групп из единиц, разделённых нулями  (в последователь-
ности нулей и единиц).

 ш1.2
    _ 1Указание . 0.
 ш1.0

   (а) <Сумма всех членов последовательности; Длина>;
   (б) <Число элементов, равных максимальному;
        Значение максимального>;
   (в) <Наибольший элемент последовательности;
        Второй по величине элемент>;
   (г) <Максимальное число идущих подряд одинаковых элементов;
          Число идущих подряд одинаковых элементов в конце
          последовательности;
            Последний элемент последовательности>;
   (д) <Максимальная длина монотонного участка;
         Максимальная длина неубывающего участка в конце
         последовательности;
           Максимальная длина невозрастающего участка в конце
           последовательности;
             Последний член последовательности>;
   (е) <Число групп из единиц; Последний член>.
 ш1.2
                22. 0  3Задачи из Единого государственного
                        3экзамена (ЕГЭ, 2006)
    21 4* 2. 0 Опишите на русском языке или на языке C алгоритм  нахождения
номера  элемента в целочисленном массиве из 30 элементов,  наименее
отличающегося от среднего значения элементов.  Если таких элементов
несколько, то можно указать номер любого из них. Можно пользоваться
функцией ABS, вычисляющей абсолютную величину своего аргумента.
    22 4* 2. 3  0Опишите на языке C алгоритм подсчёта суммы произведений пос-
ледовательных пар элементов в целочисленном массиве из  30  элемен-
тов.  (Это означает, что нужно сосчитать сумму произведений первого
и второго,  третьего и четвёртого,  пятого и  шестого  элементов  и
т.д.)
    23 4* 2. 0 Опишите на языке C алгоритм поиска номера  первого  из  двух
последовательных элементов в целочисленном массиве из 30 элементов,
произведение которых максимально (если таких пар несколько, то мож-
но выбрать любую из них).
    24 4* 2. 0 Опишите на языке C алгоритм поиска номера  первого  из  двух
последовательных элементов в целочисленном массиве из 30 элементов,
сумма которых максимальна (если таких пар несколько,  то можно выб-
рать любую из них).

    _ 1Домашнее задание . 0:
 ш1.0

   №№  21 42(1,3,5,7,9,11) 0;  22 41,3 0 ( 18 задач 0).

    _ 1Дополнительные задачи . 0: №№ 2 1 41(1-6) 0.
 ш1.2
