    2ЛАБОРАТОРНАЯ РАБОТА 6.
    2АЛГОРИТМЫ ПОИСКА: временная эффективность

 ш1.0
                               1Главное прыгнуть с обрыва - по пути у
                               1вас обязательно вырастут крылья. 0
                                                    1Автор неизвестен
 ш1.2

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Основные понятия . 0:
 ш1.0
    1- линейный поиск в массиве 0;
    1- бинарный поиск в упорядоченном массиве 0;
    1- интерполяционный поиск в массиве 0;
    1- асимптотические оценки алгоритмов поиска элемента массива 0.

 ш1.2
    _ 1Уметь . 0:
 ш1.0
   -  1конструировать программы,  использующие методы поиска  элемент
 1ов в массиве 0.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                     2Алгоритмы поиска в массиве

 ш1.0
                                1Всё 0  1испытывайте, хорошего держитесь.
                                                         11 Фес, 5 0: 121
 ш1.2

                 21. 0  3Последовательный поиск элемента
                              3в массиве
   Алгоритм поиска  всегда  отображает  процесс просмотра массива в
поисках некоторого конкретного элемента, называемого 1  _целевым . 0.
   При  _ 1последовательном поиске . 0 последовательно  просматривается  по
одному элементу массива,  начиная с первого,  до тех пор,  пока  не
найдётся целевой элемент.  Очевидно, что чем дальше в массиве нахо-
дится искомое значение, тем больше времени уйдёт на его поиск.
   При этом нет необходимости изначально сортировать массив.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 1.

 ш1.2
   Время, затрачиваемое  на последовательный поиск,  в среднем про-
порционально длине просматриваемого массива, что обозначается  7O 0(n).
   Если поиск выполняется  много  раз,  то  возможно,  имеет  смысл
по-другому организовать данные.
   Например, можно воспользоваться  1бинарным  деревом  поиска 0.  Ско-
рость  поиска  в  таком дереве,  вообще говоря,  зависит от порядка
включения в него узлов,  однако во многих случаях она будет пропор-
циональна двоичному логарифму от полного числа узлов.
                     22. 0  3Бинарный поиск элементов
                              3в массиве
   Алгоритм бинарного  поиска  элемента  в массиве сводится к тому,
что определяется окрестность целевого элемента,  которая  позволяет
уменьшить область поиска в два раза.
   При 1 бинарном поиске 0 сравнивается целевое значение  со  "средним"
элементом отсортированного  массива.  В  случае совпадения значений
поиск завершается,  в остальных случаях отбрасывается половина мас-
сива, где этого элемента явно нет.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2.

 ш1.2
                      23. 0  3Интерполяционный поиск 0
                       3в 0  3упорядоченном 0  3массиве
    _ 1Интерполяционный поиск . 0  основан  на принципе поиска в телефонной
книге или в словаре.  Вместо сравнения каждого элемента  с  искомым
как при линейном поиске,  данный алгоритм производит попытку  1предс-
 1казания 0 местонахождения элемента,  т.е.  поиск  происходит  подобно
двоичному  поиску,  но  вместо деления области поиска на две части,
интерполяционный поиск производит оценку новой  области  поиска  по
расстоянию между искомым значением и текущим значением элемента.
   Другими словами,  бинарный  поиск  учитывает  лишь знак разности
между искомым элементом и текущим значением,  а интерполирующий ещё
учитывает и модуль этой разности и по данному  значению  производит
предсказание позиции следующего элемента для проверки.
   Итак, если теперь предположить, что данные:
 ш1.1
   (1) упорядочены по возрастанию (убыванию);
   (3) распределены в массиве достаточно "равномерно",

 ш1.2
то можно значительно ускорить "сходимость"  процесса  поиска,  осу-
ществляя сужение интервала поиска из следующих неформальных сообра-
жений.
   Пусть элементы массива принимают значения от 1 до 1000 и необхо-
димо найти элемент 10,  то при первом шаге сужения всего  диапазона
поиска  гораздо эффективнее делить его не пополам (учитывая предпо-
ложение о "равномерности" распределения данных в массиве, новые ин-
тервалы  будут  содержать  значения приблизительно от 1 до 500 и от
501 до 1000), а взять левый интервал меньшим по размеру, т.к. пред-
положительно,  число  10 окажется гораздо ближе к левой границе ис-
ходного диапазона.
   Приведём выражение для вычисления индекса, соответствующего раз-
биению интервала.  Пусть A - отсортированный массив чисел, содержа-
щий n элементов, x - искомое значение.
   В дальнейшем обозначим a[i] i-й элемент массива, i=0,1,...n.
   Если известно,  что значение x расположено между a[l] и a[r], то
следующая проверка выполняется для элемента массива с индексом
 ш1.0

            x-a[l]
   l+(r-l) 77 0─────────.
           a[r]-a[l]

 ш1.2
   Приведём запись алгоритма на  _ 1псевдокоде . 0, похожим на язык C:
 ш1.0

   interpolationSearch(n,x):
     l=0;      // Левая граница поиска (элементы массива
               // нумеруются, начиная с 0)
     r=n-1;    // Правая граница поиска
     while a[l]<=x && x<=a[r]
     {
       m=l + (x - a[l]) / (a[r]-a[l])*(r-l);
              // Элемент, с которым будем проводить сравнение
       if a[m]==x
         result=m;
       if a[m]<x
         l=m+1;
       else r=m-1;
       if a[l]==x
         result=l;
       else result=-1; // Элемент не найден
     }

 ш1.2
   Следующий пример на языке С показывает простейшую реализацию ин-
терполяционного поиска.  На каждой стадии алгоритм рассчитывает по-
зицию для  следующей проверки (как при двоичном поиске) и переносит
верхнюю или нижнюю границу, определяя тем самым новую область поис-
ка, содержащую искомое значение.
                3Работа с демонстрационными примерами
 ш1.1
   См. Пример 2C.

 ш1.2
   Асимптотически интерполяционный  поиск  превосходит по своим ха-
рактеристикам бинарный поиск.
   Если ключи распределены случайным образом,  то за один шаг алго-
ритм  уменьшает количество проверяемых элементов с n до n 51/2 0,  т.е.
после k-ого шага количество проверяемых элементов уменьшается до
 ш1.0

     4(1/2) 5k
   n 4     0  .

 ш1.2
   Следовательно, остаётся проверить только два элемента (и  закон-
чить на этом поиск), когда
 ш1.0
 
                   1
   ( 51 0/ 42 0) 5k 0= 1log 4n 02= ─────.
                  1log 42 0n

 ш1.2
   В среднем интерполяционный поиск производит
 ш1.0

    1log 0( 1log 0(n))

 ш1.2
операций, где n - число элементов, для которых производится поиск.
   Число необходимых операций зависит от равномерности  распределе-
ния значений  среди элементов.  В "плохом" случае (например,  когда
значения элементов экспоненциально возрастают) интерполяционный по-
иск может потребовать  7O 0(n) операций.
   Эксперименты показали,  что интерполяционный поиск не  настолько
снижает количество выполняемых сравнений, чтобы компенсировать тре-
буемое для дополнительных вычислений время (пока размеры массива не
очень велики).  Кроме того, типичные массивы недостаточно случайны,
да  и разница между значениями  1log 0( 1log 0(n)) и  1log 0(n) становится зна-
чительной только при очень больших n.
   На практике  при  поиске в больших массивах оказывается выгодным
на ранних стадиях применять  1интерполяционный поиск 0,  а затем, когда
диапазон существенно уменьшится, переходить к  1двоичному поиску 0.

                 3Временная эффективность 0  3алгоритмов
                          3поиска 0  3в массиве

 ш1.0
                                               1О, до чего мне стыдно
                                               1Слушать, лёжа в тени,
                                               1Песню посадки риса.
                                                                1Исса
 ш1.2

   В таблице  показаны приближённые  _ 1оценки сложности алгоритмов по-
 _ 1иска в массиве . 0 (в наихудшем и наилучшем вариантах).
 ш1.0

                    ╓───────────────────┬─────────────────┐
                    ║  3Наихудший вариант 0 │  3Средний вариант 0 │
   ┌──────────── 1── 0──╫───────────────────┼─────────────────┤
   │ 1Линейный поиск   0║        7O 0(n) 1  0       │       7O 0(n)  1  0     │
   ├──────────── 1── 0──╫───────────────────┼─────────────────┤
   │ 1Бинарный поиск   0║      7O 0( 1log 42 0n)      │     7O 0( 1log 42 0n)     │
   ├──────────── 1── 0──╫───────────────────┼─────────────────┤
   │ 1Интерполяционный 0║     1  0  1  7O 0(n)  1   0     │   7O 0( 1log 42 1log 42 0n)   │
    1│поиск            0║ 1                 0   1 │   0   1             │
   └──────── 1── 0──────╨───────────────────┴─────────────────┘

 ш1.2
   При анализе  1наихудшего варианта 0 оценивают максимальный объём ра-
боты,  необходимой для решения задачи заданного размера, а при ана-
лизе  1среднего варианта 0 - вероятный объём работы.
   Таким образом, бинарный поиск намного лучше линейного.
   Например,  1log 42 01000000=19,  поэтому алгоритм линейного поиска вы-
полнит миллион сравнений,  в то время как алгоритм бинарного поиска
- не более 20.  Если размерность массива велика,  то бинарный поиск
намного эффективнее линейного. Однако следует иметь в виду, что ус-
ловие упорядоченности массива приводит к  дополнительным  затратам,
которые могут быть существенными.
   Сравним, например,  эффективность алгоритмов линейного поиска  и
бинарного поиска в массиве.  Очевидно, что при количестве элементов
в массиве, равном 100000, получается выигрыш примерно в 6000 раз.
 ш1.0

                      ╓─────────────────────────────┐
                      ║      3Количество операций 0     │
   ┌──────────────────╫────────┬────────────────────┤
   │ 1Количество элемен- 0║ 1Линейный 0│       1Бинарный  0     │
   │ 1тов в массиве 0    1   0║  1поиск 0  │        1поиск 0        │
   ╞══════════════════╬════════╪════════════════════╡
   │          10      ║     10 │  1log 42 0(    10) 7~ 0 3.32 │
   │         100      ║    100 │  1log 42 0(   100) 7~ 0 6.64 │
   │        1000      ║   1000 │  1log 42 0(  1000) 7~ 0 9.96 │
   │       10000      ║  10000 │  1log 42 0( 10000) 7~ 013.28 │
   │      100000      ║ 100000 │  1log 42 0(100000) 7~ 016.06 │
   └──────────────────╨────────┴────────────────────┘
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ

 ш1.0
                              1Если я не буду протирать звёзды каждый
                              1вечер, они обязательно потускнеют. 0
                                              1Из м/ф "Ёжик в тумане"
 ш1.2

                    21. 3 Алгоритмы поиска в массиве
    21. 0 [Рафгарден,2019,с.67-68]
   Каково асимптотическое  время выполнения приведённого ниже  1псев 0-
 1докода 0 для поиска в массиве как функции длины n массива?
    _ 1Вход . 0: массив A из n целых чисел и искомое целое число t.
    _ 1Выход . 0: содержит или нет массив A число t.
 ш1.0

   for i:=1 to n do             ║ (а) 7 O 0(1);
     if A[i]=t                  ║ (б) 7 O 0( 1log 0(n));
       then return True         ║ (в) 7 O 0(n);
   return False                 ║ (г) 7 O 0(n 52 0).

 ш1.2
    22. 0 (По [Рафгарден,2019,с.68-69])
   Каково асимптотическое  время выполнения приведённого ниже  1псев 0-
 1докода 0?
    _ 1Вход . 0: массивы A и B из n целых чисел и искомое целое число t.
    _ 1Выход . 0: содержат или нет массивы A или B число t.
 ш1.0

   for i:=1 to n do             ║ (а) 7 O 0(1);
     if A[i]=t                  ║ (б) 7 O 0( 1log 0(n));
       then return True         ║ (в) 7 O 0(n);
     if B[i]=t                  ║ (г) 7 O 0(n 52 0).
       then return True
   return False

 ш1.2
    23. 0 (По [Рафгарден,2019,с.69-70])
   Каково асимптотическое  время  выполнения приведённого ниже  1псев 0-
 1докода 0?
    _ 1Вход . 0: массивы A и B из n целых чисел.
    _ 1Выход . 0: содержится ли целое число t в обоих массивах A и B.
 ш1.0

   for i:=1 to n do             ║ (а) 7 O 0(1);
     for j:=1 to n do           ║ (б) 7 O 0( 1log 0(n));
       if A[i]=B[j]             ║ (в) 7 O 0(n);
         then return True       ║ (г) 7 O 0(n 52 0).
   return False

 ш1.2
    24. 0 (По [Рафгарден,2019,с.70-71])
   Каково асимптотическое время выполнения приведённого  ниже   1псев-
 1докода 0?
    _ 1Вход . 0: массив A из n целых чисел.
    _ 1Выход . 0: содержит  ли  массив A некоторое целое число более одного
раза или нет.
 ш1.0

   for i:=1 to n do             ║ (а) 7 O 0(1);
     for j:=i+1 to n do         ║ (б) 7 O 0( 1log 0(n));
       if A[i]=A[j]             ║ (в) 7 O 0(n);
         then return True       ║ (г) 7 O 0(n 52 0).
   return False

 ш1.2
    25. 0 (По [Окулов,2002,с.277])
   Напишите программу,  осуществляющую поиск элемента массива, бли-
жайшего к его наименьшему элементу.
    26. 0 Напишите программу, осуществляющую " 1одновременный 0" поиск наи-
меньшего и наибольшего элемента массива.
    27. 0 (По [Окулов,2002,с.269])
   Дана позиция элемента Pos в упорядоченном массиве A из N элемен-
тов и количество допустимых сравнений L.
   Определите все интервалы значений в диапазоне [1,10000], при ко-
торых элемент  A  с  номером Pos может быть найден за L сравнений с
помощью  1бинарного поиска 0 в упорядоченном массиве.
 ш1.1
    _ 1Указание . 0.
 ш1.0

   import List
   -- ***********************
   res a lst = search a lst 0
   ----------------------------------------
   search:: Ord a => a -> [a] -> Int -> Int
   search a lst res | null lst        = res
                    | length lst == 1 = res + 1
                    | a == mid        = res + 1
                    | a <  mid        = search a lst1 (res + 1)
                    | a >  mid        = search a lst2 (res + 1)
        where mid  = last lst1
              z    = length lst `div` 2
              lst1 = take z lst
              lst2 = drop z lst
   ----------------------------------------------------
   test k = filter (\x -> res 10 [1..x] == k) [1..1000]

 ш1.1
    _ 1Тесты . 0.
   Если Pos=10, L=3, то: (12,12), (16,17), (28,29), (80,87).
   Если Pos=9000, L=2, то решений нет.

 ш1.2
    28 5* 2. 0 (По [Окулов,2002,с.270])
   Напишите программу,  осуществляющую поиск k-го элемента в неупо-
рядоченном массиве A с помощью  _ 1случайного поиска . 0, который состоит в
следующем: выбирается случайным образом элемент с номером q, а мас-
сив разбивается на три части: элементы, меньшие A[q], равные A[q] и
большие A[q]; далее, в зависимости от количества элементов в каждой
части рекурсивно выбирается одна из частей для дальнейшего поиска.
    29. 0 [Поляков,Ерёмин,2013,ч.2,с.34]
   Предложите алгоритм, позволяющий найти и вывести на экран симво-
лы, которые встречаются в строке более одного раза.
    210. 0 [Рафгарден,2019,с.127]
   Дан  1унимодулярный массив 0 из n различных элементов, что означает,
что его элементы находятся в строго возрастающем порядке до  своего
максимального элемента,  после чего его элементы находятся в строго
убывающем порядке.  Разработайте алгоритм вычисления  максимального
элемента унимодального массива, выполняющийся за время  7O 0( 1log 0(n)).
    211. 0 [Рафгарден,2019,с.127]
   Дан отсортированный  (от  наименьшего  до  наибольшего элемента)
массив A из n разных целых чисел, которые могут быть  положительны-
ми, отрицательными или нулевыми. Определите, существует ли индекс i
такой, что A[i]=i.
   Разработайте самый быстрый алгоритм для решения этой задачи.
                         22. 0  3Медиана массива
    21.  0Напишите программу для нахождения медианы в массиве,  опираю-
щуюся на следующий алгоритм:  вначале произведите сортировку масси-
ва, а затем выберите "средний" элемент.
 ш1.1
    _Указание ..  _ 1Медианой массива,  содержащего . 4  1N  _элементов . 0, называется
элемент,  значение которого меньше (или равно) половины N элементов
и больше (или равно) другой половины.
   Например, медианой массива, содержащего элементы 16 1, 0 22 1, 0 99 1, 0 95,
18, 87, 10 является 18.

 ш1.2
    22. 0 Напишите программу,  определяющую, есть ли в заданном массиве
мажорирующий элемент, и если есть, то укажите его.
 ш1.1
    _Указание ..  _ 1Мажорирующим элементом массива . 0 A[1..N] называется эле-
мент, встречающийся в массиве более  5N 0/ 42 0 раз.

 ш1.2
                           23. 0  3Мода 0  3массива
    21. 0 Напишите программу, которая либо вычисляет  1моду массива 0, либо
устанавливает, что массив её не имеет.
 ш1.1
    _Указание ..  _ 1Модой массива . 0 называется число M,  которое встречается
в массиве наиболее часто. Если в массиве имеется несколько наиболее
часто встречающихся элементов и число их  вхождений  совпадает,  то
считается, что массив не имеет моды.

 ш1.2
                         3Контрольные задания
    21. 0 (По [Поляков,Ерёмин,2013,ч.2,с.34])
   Оцените количество операций для алгоритмов:
 ш1.1
   (а) нахождения минимального и максимального элементов массива;
   (б) определения количества положительных элементов массива;
   (в) поиска всех делителей числа;
   (г) проверки числа на простоту.

 ш1.2
    22. 0 (По [Кормен,Лейзерсон,Ривест,Штайн,2010,с.133-134,№4-2])
   Массив A[1..n] содержит все целые числа от 0 до n, кроме одного.
   Найдите пропущенное число.
   Конечно, можно  отмечать  во вспомогательном массиве B[0..n] все
числа,  встречающиеся в массиве A, а затем найти неотмеченное число
(всё вместе требует времени  7O 0(n)).  При этом  _ 1элементарной операцией
считается использование элемента массива A в качестве индекса.
   Пусть теперь   _ 1элементарной операцией . 0 является просмотр заданного
бита элемента массива A.  Покажите (написав программу), что при та-
ких ограничениях можно найти пропущенное число за время  7O 0(n).
    23. 0 (По [Левитин,2006,с.98])
   Вы подошли вплотную к стене, не имеющей ни начала, ни конца.
   Известно, что  в стене есть дверь,  но вы не знаете в каком  на-
правлении и как долго нужно двигаться, чтобы найти эту дверь. Заме-
тить дверь в стене можно,  только подойдя непосредственно к  ней  и
став напротив.
   Разработайте алгоритм,  который позволяет находить дверь в стене
методом обхода не более чем за  7O 0(n) шагов,  где n - неизвестное за-
ранее число шагов между вашим первоначальным положением и дверью.

    _ 1Домашнее задание . 0 (19.04 - 26.04.2019):
 ш1.0

   №№  21 41,2,3,4,5,6,11 0 ( 17 задач 0).

    _ 1Дополнительные задачи . 0: №№ ...
 ш1.2
