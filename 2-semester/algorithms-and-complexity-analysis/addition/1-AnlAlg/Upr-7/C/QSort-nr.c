   /* Демонстрация нерекурсивной реализации алгоритма */
   /* быстрой сортировки.                             */
   /* В программе использован тип данных - struct и   */
   /* структура данных - стек (моделируется массивом) */
   /* ----------------------------------------------- */
   #include<stdio.h>
   #include<stdlib.h>
   #include<conio.h>
   #include<time.h>
   #define N 5     /* Количество элементов в массиве */
   #define M 12    /* Глубина стека                  */
     struct zapis
     {
       int l,r;
     };
  /* ------ */
   int main()
   {
      struct zapis stack[M]; /* Стек                              */
      int a[N+1],            /* Исходный массив                   */
          i,j,               /* Параметры циклов                  */
          l,r,               /* Диапазон индекса элемента массива */
          x,                 /* "Средний" элемент массива a[]     */
          w,                 /* Вспомогательная переменная        */
          s;                 /* Индекс элемента стека             */
      /* -------------------------------------------------------- */
      printf("Введите натуральное число: "); scanf("%u",&i);
      srand(i?i:time(NULL));
      /* Ввод "случайного" массива */
      for (i=1;i<=N;i++)
        a[i]=rand()%10;
      /* Контрольный вывод массива */
      printf("Исходный массив: ");
      for (i=1;i<=N;i++)
        printf("%u ",a[i]);
      printf("\n");
      /* -------------------------- */
      s=1; stack[s].l=1; stack[s].r=N;
      do
      {
        /* Выбор из стека последнего запроса */
        l=stack[s].l; r=stack[s].r; s--;
        do
        {
          /* Разделение a[l],...,a[r] */
          i=l; j=r; x=a[(l+r)/2];
          do
          {
            while (a[i]<x)
              i++;
            while (x<a[j])
              j--;
            if (i<=j)
            {
              w=a[i]; a[i]=a[j]; a[j]=w; i++; j--;
            }
          }
          while (i<=j);
          if (i<r)
          {
            /* Запись в стек запроса из правой части */
            s++; stack[s].l=i; stack[s].r=r;
          }
          r=j;  /* Теперь l и r ограничивают левую часть */
        } while (l<r);
      } while (s!=0);
      printf("Результат:       ");
      for (i=1;i<=N;i++)
        printf("%d ",a[i]);
      printf("\n");
      getch();
      return 0;
   }
