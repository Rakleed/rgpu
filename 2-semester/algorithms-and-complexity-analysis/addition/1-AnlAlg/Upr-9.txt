    2ЛАБОРАТОРНАЯ РАБОТА 9.
    2ЭМПИРИЧЕСКИЙ АНАЛИЗ АЛГОРИТМОВ. ВИЗУАЛИЗАЦИЯ АЛГОРИТМОВ

                  2ОБЯЗАТЕЛЬНЫЕ РЕЗУЛЬТАТЫ ОБУЧЕНИЯ
    _ 1Уметь . 0:
 ш1.1
   - проводить эмпирический анализ заданного алгоритма.
 ш1.2

                       2ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                   2Эмпирический анализ алгоритмов

 ш1.0
           1Алан знал, что люди даже не могут представить геологичес-
           1кое время.  Вся человеческая жизнь подчиняется совершенно
           1другим временным понятиям...  Ни одно из ... повседневных
           1изменений не может подготовить человека к пониманию того,
           1что вмещают в себя восемьдесят миллионов лет. 0
                                     1М.Крайтон. Парк юрского периода
 ш1.2

   Принципиальной альтернативой  1математическому  анализу  эффектив-
 1ности алгоритмов 0 является их  1эмпирический анализ 0.
   Приведём примерный   _ 1план проведения эмпирического анализа эффек-
 _ 1тивности алгоритма . 0 [Левитин,2006,с.127]:
 ш1.1
   (1) выяснение цели предстоящего эксперимента;
   (2) определение  измеряемой  метрики M и единиц измерения (коли-
чество операций или время работы);
   (3) определение характеристик образца входных данных (их  диапа-
зон, размер и т.д.);
   (4) создание  программы,  реализующей  алгоритм (или алгоритмы),
для проведения эксперимента;
   (5) генерация входных данных;
   (6) выполнение алгоритма (или алгоритмов) над входными данными и
запись наблюдаемых данных;
   (7) анализ полученных данных с учётом метрики M и единиц измере-
ния.

 ш1.2
   Рассмотрим по очереди некоторые из указанных шагов.

    21. 0 Имеется ряд целей,  которые могут быть поставлены перед эмпи-
рическим анализом алгоритмов:
 ш1.1
   (а) проверка точности теоретических выводов об эффективности ал-
горитма;
   (б) сравнение эффективности нескольких алгоритмов, предназначен-
ных для решения одной и той же проблемы  или  различных  реализаций
одного  или того же алгоритма;
   (в) выдвижение гипотезы о классе эффективности алгоритма;
   (г) выяснение эффективности программы,  реализующей алгоритм, на
данном конкретном компьютере.

 ш1.2
   Очевидно, что разработка эксперимента должна зависеть  от  того,
на какой именно вопрос он должен ответить.

    22. 0 В частности,  цель эксперимента должна определять  то,  каким
образом будет выполняться измерение эффективности алгоритма.
    _ 1Первый вариант . 0 заключается включением в  программу,  реализующую
алгоритм,  1счётчиков 0, которые будут подсчитывать количество выполне-
ний алгоритмом базовых операций.
   Обычно это  достаточно  просто,  и вы должны только не забывать,
что базовые операции могут выполняться не в одном месте  программы,
и  учитывать  все  возможные их выполнения.  Само собой,  вы всегда
должны проверять модифицированную таким  образом  программу,  чтобы
убедиться в её корректности - как в смысле решения поставленной пе-
ред алгоритмом задачи, так и в смысле корректности работы внесённых
в программу счётчиков.
    _ 1Второй вариант . 0 заключается в определении времени работы програм-
мы, реализующей исследуемый алгоритм.
   Простейший путь выяснения времени работы - это запрос к операци-
онной системы по сообщению времени,  затраченного на выполнение ва-
шей программы (в Unix это время называется  1пользовательским  време-
 1нем 0 и автоматически предоставляется командой time).
   Можно также определять время работы фрагмента  кода,  запрашивая
 1системное  время 0 непосредственно перед началом выполнения фрагмента
(t 4start 0) и сразу после его завершения (t 4finish 0), а затем просто вы-
числять разность полученных значений t 4finish 0-t 4start 0.
   Если системное время возвращается в "тиках" ( 1ticks 0),  то необхо-
димо не забыть разделить полученное число на константу,  определяю-
щую количество "тиков" в единице времени.
   В языках C и C++ для этой цели используется функция clock(), а в
языке Java - метод currentTimeMillis() из класса System.
   Однако очень важно не забывать о некоторых вещах:
 ш1.1
   (1) системное время обычно не очень точное, и вы можете получить
несколько отличающиеся друг от друга результаты при  повторных  за-
пусках  одной и той же программы с одними и теми же входными данны-
ми.  Очевидным средством противодействия этому эффекту является за-
пуск программы и выполнение измерений  1несколько раз 0,  с последующим
усреднением полученных результатов;
   (2) высокое  быстродействие  современных  компьютеров приводит к
тому, что время работы невозможно зарегистрировать (получаются  ну-
левые результаты). Обойти эту неприятность легко, запуская програм-
му в цикле много раз,  а затем поделив зарегистрированное время вы-
полнения на количество итераций цикла;
   (3) на компьютере, работающем под управлением многозадачной опе-
рационной системы (как например,  Unix), регистрируемое время может
включать время,  затраченное процессором на работу над другими про-
цессами, что мешает проведению эксперимента.

 ш1.2
   Итак, измерение физического времени работы имеет ряд недостатков
как  принципиального характера (наиболее важным из них является за-
висимость от конкретного компьютера, на которой проводится экспери-
мент),  так  и  технических,  которых нет у метода подсчёта базовых
операций.
   С другой стороны,  измерение физического времени даёт конкретную
информацию о производительности алгоритма в  данной  вычислительной
среде,  что для экспериментатора может оказаться более важным, чем,
скажем,  1класс асимптотической эффективности алгоритма 0.
   Кроме того,  измерения времени,  затраченного на различные части
программы,  могут помочь выявить узкие места  в  производительности
программы. Получение таких данных,  которое называется  _ 1профилирова-
 _ 1нием . 0, - это важный ресурс для эмпирического анализа времени  работы
алгоритмов; обычно в большинстве сред имеются специальные системные
инструменты для получения данной информации.

    23. 0 Независимо от того,  решите ли вы измерять производительность
алгоритма  при  помощи подсчёта базовых операций или фиксируя время
выполнения,  возникает вопрос о выборе  _ 1образца исходных данных . 0  для
проведения  эксперимента.  Зачастую  требуется использовать образец
входных данных, представляющий собой "типичные" данные.
   Для некоторых классов алгоритмов - например,   1алгоритмов для ре-
 1шения  задачи  коммивояжёра 0,  - исследователи разработали набор эк-
земпляров задач, которые используются в качестве тестовых образцов.
   Однако на практике гораздо чаще приходится сталкиваться с ситуа-
циями, когда входные данные должен выбирать и готовить сам экспери-
ментатор.  Обычно  приходится  самостоятельно решать,  каков должен
быть размер входных данных (разумно начать с данных небольшого раз-
мера и и при необходимости постепенно увеличивать их), диапазон ве-
личин входных данных (чтобы он не был ни слишком малым,  ни слишком
большим),  и разрабатывать процедуру для генерации входных данных в
выбранном диапазоне.
   Обычно данные либо следуют некоторому шаблону (например,
 ш1.0

   1000, 2000,..., 10000 или 500, 1000, 2000, 4000,..,128000),

 ш1.2
либо генерируются случайным образом (например,  с равномерным расп-
ределением между наименьшим и наибольшим значениями).
   Главное достоинство следования определённому шаблону в том,  что
в этом случае легче проанализировать влияние данных на работу и эф-
фективность алгоритма.
   Например, если значения входных данных генерируются путём удвое-
ния, можно вычислить отношение
 ш1.0

   M(2n)/M(n)

 ш1.2
наблюдаемой метрики M (количество операций или  время)  и  увидеть,
является ли  поведение  алгоритма  типичным  для одного из  _ 1основных
 _ 1классов эффективности . 0.
   Основной недостаток неслучайных величин - это возможность  того,
что  для  конкретного набора данных алгоритм продемонстрирует нети-
пичное поведение. Например, если все значения входных данных чётны,
а  исследуемый  алгоритм  для  нечётных данных работает существенно
медленнее, результат эксперимента окажется далёк от истины.
   Ещё один важный вопрос,  связанный со входными данными:  следует
ли  использовать несколько экземпляров данных одного и того же раз-
мера.
   Если вы ожидаете,  что наблюдаемая метрика может существенно из-
меняться даже для данных одного и того же размера,  вероятно, будет
разумно включить во входные  данные  несколько  разных  экземпляров
данных.  (В  математической статистике имеются хорошо разработанные
методы,  которые могут помочь в выработке верного решения в  данной
ситуации.)  Само  собой,  при  использовании нескольких экземпляров
данных наблюдаемые значения для каждого размера данных должны  быть
усреднены.
   Весьма часто эмпирический анализ эффективности требует  _ 1генерации
 _ 1случайных чисел . 0. Даже используя для входных данных шаблон, мы обыч-
но хотим, чтобы сами экземпляры данных генерировались случайным об-
разом.  Генерация  случайных чисел на цифровом компьютере,  как из-
вестно, представляет собой сложную задачу, которая в принципе может
быть решена только приближённо.
   В этом,  в частности, заключается причина того, что программисты
предпочитают именовать такие числа  _ 1псевдослучайными . 0.
   С практической точки зрения простейший и  наиболее  естественный
способ  получения  таких  чисел  состоит в использовании  _ 1генератора
 _ 1случайных чисел . 0 из библиотеки используемого языка программирования.
Обычно  такой  генератор  даёт  на выходе псевдослучайные значения,
равномерно распределённые в интервале от 0 до 1.
   Если же требуются некоторые другие псевдослучайные значения,  то
можно применить соответствующие преобразования.
   Например, если  x  - непрерывная случайная величина,  равномерно
распределённая в диапазоне 0 7, 0x<1, то величина
 ш1.0

   y=l+[x 77 0(r-l)]

 ш1.2
будет представлять собой целую величину,  равномерно распределённую
в диапазоне между целыми числами l и r-1 (l<r).
   Вы можете не пользоваться  1библиотечным генератором 0,  а  реализо-
вать  один из множества известных алгоритмов для генерации псевдос-
лучайных чисел.
   Широко используемым и детально изученным является  _ 1линейный конг-
 _ 1руэнтный метод . 0 [Левитин,2006,с.130-131]:
 ш1.0

   Алгоритм Random(n,m,seed,a,b)
   // Генерирует последовательность из n псевдослучайных чисел
   // с использованием линейного линейного конгруэнтного метода
   //   _ 1Входные данные . 0: натуральное число n и натуральные пара-
   //                  метры m, seed, a, b
   //   _ 1Выходные данные . 0: последовательность r 41 0,...,r 4n 0 псевдослу-
   //                   чайных чисел, равномерно распределённых
   //                   между 0 и m-1
   //   _ 1Примечание . 0: псевдослучайные числа между 0 и 1 могут быть
   //              получены путём рассмотрения генерируемых ал-
   //              горитмом целых чисел как цифр после десятич-
   //              ной точки
   // ----------------------
      r 40 0=seed
      for i:=1 to n do
        r 4i 0:=(a*r 4i-1 0+b)  1mod 0 m

 ш1.2
   Простота приведённого  алгоритма обманчива,  поскольку все слож-
ности скрыты в выборе параметров алгоритма.
   Приведём  _ 1список рекомендаций . 0,  основанных на результатах матема-
тического анализа:
 ш1.1
   (1) значение  seed  можно выбрать произвольным образом (зачастую
для этого используются текущая дата и время);
   (2) m  должно  быть большим (может оказаться удобным выбор для m
величины 2 5w 0, где w - размер слова компьютера);
   (3) a должно быть целым целым числом от 0.01m до 0.99m без опре-
делённой закономерности в его цифрах, но такое, что
 ш1.0

   a  1mod 0 8=5;

 ш1.1
   (4) значение b может быть выбрано равным 1.
 ш1.2

    24. 0 Эмпирические данные,  полученные в ходе эксперимента,  должны
быть записаны, а затем представлены для дальнейшего анализа.
   Данные могут быть представлены в таблице или графически, точками
в декартовой системе координат. Можно использовать одновременно оба
способа,  поскольку  для  каждого  характерны свои сильные и слабые
стороны.
   Основное преимущество табулированных данных заключается  в  лёг-
кости доступа и работы с ними.
   Например, мы можем вычислить отношения M(n) / g(n),  где g(n)  -
кандидат в представители класса эффективности исследуемого алгорит-
ма.
   Если алгоритм действительно принадлежит 7 Q 0(g(n)),  то,  вероятнее
всего, эти  отношения  будут  сходиться  к  некоторой положительной
константе при возрастании n.
   Мы можем  также  вычислить  отношения M(2n) / M(n) и посмотреть,
как ведёт себя время работы алгоритма при удвоении размера  входных
данных  (в  случае  логарифмического алгоритма это отношение должно
изменяться очень слабо, а для линейного, квадратичного и кубическо-
го алгоритмов - сходиться к 2, 4 и 8, соответственно).

    25. 0 Графическое  представление данных также может помочь в выдви-
жении гипотезы о вероятном классе эффективности алгоритма:
 ш1.1
   (1) в случае  1логарифмического алгоритма 0  график  имеет  выпуклый
вверх  вид.  Этот вид графика отличает логарифмические алгоритмы от
всех прочих алгоритмов;
   (2) в  случае   1линейного алгоритма 0 экспериментальные точки имеют
тенденцию выстраиваться вдоль прямой линии или располагаться  между
двумя прямыми линиями;
   (3) графики функций из классов  7Q 0(n 77 1lg 0(n)) и  7Q 0(n 52 0) имеют  " 1выпук-
 1лый вниз 0" вид, что делает их идентификацию более сложной;
   (4) график для кубического алгоритма также имеет " 1выпуклый вниз 0"
вид, но растёт с существенно более высокой скоростью.

 ш1.2
   Одно из возможных применений эмпирического анализа - это попытка
предсказать производительность алгоритма  для  экземпляра  исходных
данных,  не  включённого  во  множество экземпляров исходных данных
эксперимента.
   Например, если заметим, что отношение M(n)/g(n) близко к некото-
рой константе k для экземпляров,  использованных в эксперименте, то
мы  можем  аппроксимировать  M(n)  произведением kg(n) и для других
значений n.
   Хотя этот подход вполне разумен,  его следует использовать с ос-
торожностью,  в особенности для значений n,  которые находятся  вне
экспериментально исследованного диапазона.  Математики называют та-
кое предсказание  _ 1экстраполяцией . 0 в отличие от  _ 1интерполяции . 0,  которая
работает со значениями в пределах исследуемого диапазона.
   В частности, нельзя ничего сказать о точности таких оценок.
   Конечно, можно попытаться применить стандартные методы статисти-
ческого анализа данных,  однако заметим, что они в основном базиру-
ется  на  определённых вероятностных предположениях,  которые могут
оказаться неверны для рассматриваемых экспериментальных данных.
    _ 1Выводы . 0.
 ш1.1
   Перечислим основные  отличия между математическим и эмпирическим
анализом алгоритмов.
   Главным преимуществом математического анализа является его неза-
висимость от конкретных входных входных данных, а недостатком - ог-
раниченная применимость,  в особенности для исследования  эффектив-
ности в среднем случае.
   Эмпирический анализ,  напротив,  применим к любому алгоритму, но
его результаты могут зависеть от конкретных входных данных и компь-
ютера, использованного для проведения эксперимента.

 ш1.2
    3Замечания 0.
 ш1.1
    21. 0 Точное время обработки массива определяется так:
 ш1.0

   T(n)=n 52 0+5n+10.

 ш1.1
   "Грубое" время обработки массива определяется так:
 ш1.0

   T(n)=1.1n 52 0.

 ш1.1
    22. 0 Если обратиться к англоязычной периодике  по  алгоритмизации,
то окажется, что значительная часть статей (не "пионерских") пишет-
ся по следующей схеме:
 ш1.1
   (1) рассматривается алгоритм или несколько алгоритмов одного ти-
па;
   (2) в лучшем случае (но не всегда) проводится его модификация;
   (3) даются результаты его  1экспериментальной оценки 0.  Эксперимент
строится традиционным методом:  серия тестов, на которых оценивают-
ся, например, время работы и используемая память алгоритма.
 ш1.2

                       2Визуализация алгоритмов

 ш1.0
       1- Вообрази себе 0: 1  это там в нервах,  в голове,  то есть там в
       1мозгу эти нервы ... есть такие этакие хвостики, у нервов этих
       1хвостики,  ну,  и как только они там задрожат...  то есть ви-
       1дишь, я посмотрю на что-нибудь глазами, вот так, и они задро-
       1жат, хвостики-то... а как задрожат, то и является образ...
               1Ф.М.Достоевский. Братья Карамазовы. Ч.IV, кн.11, гл.4
 ш1.2

   Помимо математического  и эмпирического анализа имеется ещё один
путь изучения алгоритмов, называемый  _ 1визуализацией алгоритма . 0.
    2Определение 0 ( 1содержательное 0) (по [Левитин,2006,с.135-139]).
 ш1.1
    _ 1Визуализацией алгоритма . 0 называется использование изображений для
передачи некоторой  1полезной информации об алгоритмах 0.  Эта информа-
ция может быть визуальной иллюстрацией действий,  выполняемых алго-
ритмом,  или его производительности для разных входных данных, либо
его  скорости выполнения по сравнению с другими алгоритмами для ре-
шения той же задачи.  Для достижения данной цели визуализация алго-
ритма использует графические элементы (точки,  отрезки, прямоуголь-
ники или параллелепипеды и т.д.) для представления некоторых "инте-
ресных событий" в работе алгоритма.

 ш1.2
   Имеются  _ 1два основных варианта визуализации алгоритма . 0:
 ш1.1
   (1)  _ 1статическая визуализация . 0,  которая  представляет  выполнение
алгоритма посредством серии изображений;
   (2)  _ 1динамическая визуализация . 0 (называемая также  _ 1анимацией  алго-
 _ 1ритма . 0)  и использующая непрерывное представление действий алгоритма
в стиле мультфильма.  Анимация - более привлекательный  выбор,  но,
конечно, она существенно сложнее в реализации.

 ш1.2
    2Определение 0 (по [Поликарпова,Шалыто,2009,с.146]).
 ш1.1
    _ 1Визуализатор . 0 - это программа, в процессе работы которой на экра-
не компьютера динамически демонстрируется  применение  алгоритма  к
выбранному набору данных.
   Визуализаторы позволяют изучать работу алгоритмов как в  автома-
тическом, так и в пошаговом режиме,  аналогичном режиму трассировки
программ. Визуализация шагов алгоритма может сопровождаться  1тексто-
 1выми комментариями 0.

 ш1.2
   При рассмотрении и оценке различных  анимаций  алгоритмов  можно
пользоваться  приведёнными  ниже " _ 1десятью заповедями анимации алго-
 _ 1ритмов . 0" - списком желательных возможностей пользовательского интер-
фейса, предложенных П.Глуром (P.Gloor), главным разработчиком попу-
лярной системы визуализации алгоритмов  1Animated Algorithms 0:
 ш1.1
   (1) последовательность;
   (2) интерактивность;
   (3) ясность и краткость;
   (4) снисходительность к пользователю и прощение его ошибок;
   (5) адаптация к уровню знаний пользователя;
   (6) упор на визуальную часть;
   (7) удержание интереса пользователя;
   (8) включение символьного и пиктограммного представления;
   (9) включение  анализа алгоритма (статистики выполнения) и срав-
нение с другими алгоритмами для решения той же задачи;
   (10) включение истории выполнения.

 ш1.2
   Перечислим основные области применения визуализации алгоритмов:
 ш1.1
   (1)  1научные исследования 0:  потенциальная польза  визуализации  в
исследовательской работе заключается в возможности открытия некото-
рых неизвестных свойств алгоритма;
   (2)  1образование 0: применение визуализации алгоритмов призвано по-
мочь студентам в изучении алгоритмов.

 ш1.2
   Например, один  исследователь использовал визуализацию рекурсив-
ного алгоритма для решения задачи о  ханойских  башнях,  в  которой
чётные и нечётные диски имели разные цвета.  Он обратил внимание на
то,  что два диска одного цвета никогда не находятся  в  непосредс-
твенном  контакте  в процессе выполнения алгоритма.  Это наблюдение
позволило ему разработать лучшую нерекурсивную версию классического
алгоритма.
   Однако, хотя и имеется масса сообщений  об  успешном  применении
визуализации  в образовании и научных исследованиях,  эти успехи не
столь впечатляющи,  как можно было бы ожидать. Опыт показывает, что
создания  сложной программной системы недостаточно - требуется глу-
бокое понимание восприятия визуальной информации  человеком,  чтобы
добиться полного раскрытия потенциала анимации алгоритма.
   Первые попытки визуализации алгоритмов относятся к 1970-м годам.
   Переломным моментом стало  появление  классической  визуализации
алгоритма - тридцатиминутного цветного звукового фильма " 1Сортировка
 1за сортировкой 0" (1981).  Фильм был создан в университете г. Торонто
Р.Беккером (R.Baecker) при участии Д.Шермана (D.Sherman) и содержал
визуализацию девяти популярных алгоритмов сортировки и демонстриро-
вал их относительные скорости.
   Успех фильма " 1Сортировка за сортировкой 0" сделал алгоритмы сорти-
ровки несомненными  фаворитами  анимации алгоритмов.  В самом деле,
проблема сортировки естественным образом визиализируется с  исполь-
зованием вертикальных  или горизонтальных прямоугольников различной
высоты или длины,  которые расставляются в соответствии с их разме-
рами. Такое представление,  однако, удобно лишь для иллюстрации ра-
боты алгоритмов сортировки при небольших входных данных.
   Для входных данных большого размера в фильме " 1Сортировка за сор-
 1тировкой 0" использована идея представления данных точками  на  плос-
кости,  где первая координата точки представляет позицию элемента в
массиве данных,  а вторая - его значение.  При использовании такого
представления  данных  сортировка  представляет собой трансформацию
случайного заполнения точками в точки, лежащие на диагонали кадра.
   Кроме того, большинство алгоритмов сортировки работает путём по-
очерёдного сравнения и обмена двух элементов - событие, которое от-
носительно просто визуализировать.
   После появления " 1Сортировки за сортировкой 0"  было  создано  мно-
жество различных анимаций алгоритмов.  Анимации могут содержать как
один алгоритм,  так и группу алгоритмов для решения одной и той  же
задачи  (сортировки) или из одной и той же предметной области (гео-
метрические алгоритмы),  а также  представлять  собой  анимационные
системы общего назначения.
   Наиболее популярные системы общего  назначения  включают  BALSA,
TANGO и ZEUS (ссылку см. в [Левитин,2006,с.136]). Хорошая  анимаци-
онная система общего назначения должна  позволять  пользователю  не
только  просматривать  и взаимодействовать с имеющимися анимациями,
но и позволяет создавать новые анимации.  Практика показывает,  что
создание таких систем - сложная (но решаемая) задача.
   Появление языка  Java  и WWW дало новый толчок развитию анимации
алгоритмов (обратитесь к Internet и познакомьтесь с образцами  ани-
мации алгоритмов: попробуйте осуществить поиск по словам " 1Algorithm
 1animation 0" или " 1Algorithm visualization 0").
    3Замечание 0 ( 1важное 0).
 ш1.1
   С понятием " 1визуализация алгоритмов 0" тесно связаны понятия  " 1ви-
 1зуализация  структур данных 0" и " 1визуализация АТД  0( 1абстрактных типов
 1данных 0)".
 ш1.2

                      2ДЕМОНСТРАЦИОННЫЕ ПРИМЕРЫ
    2Пример 0  21. 0 Воспользуемся  1интерполяцией 0 для   1эмпирического анализа
времени работы компьютерной программы рекурсивного вычисления чисел
Фибоначчи, в результате работы которой получены такие результаты:
 ш1.0

   ┌────┬───────────────┬───────────┐
   │  3n 0  │ 3Числа Фибоначчи 0│ 3Время счёта 0│
   ╞════╪═══════════════╪═══════════╡
   │ 28 │     317811    │ 0.220 сек │
   │ 29 │     514229    │ 0.385 сек │
   │ 30 │     832040    │ 0.549 сек │
   │ 31 │    1346269    │ 0.879 сек │
   │ 32 │    2178309    │ 1.484 сек │
   │ 33 │    3524578    │ 2.418 сек │
   │ 34 │    5702887    │ 3.846 сек │
   │ 35 │    9227465    │ 6.264 сек │
   │ 36 │   14930352    │10.165 сек │
   │ 37 │   24157817    │16.374 сек │
   └────┴───────────────┴───────────┘

 ш1.2
   Воспользуемся следующей  функцией математического пакета MatLab,
которая реализует вычисление коэффициентов  аппроксимирующего  мно-
гочлена степени n методом наименьших квадратов:
 ш1.0

   polyfit(x,y,n),

 ш1.2
где x и y - векторы данных зависимости y=y(x),  n - степень многоч-
лена. При этом:
 ш1.1
   (1) реализуется   _ 1интерполяция . 0 (при этом график многочлена прохо-
дит точно через исходные точки),  если число элементов в векторах x
и y равно n+1;
   (2) реализуется  приближение  функции  y=y(x)  _ 1методом наименьших
 _ 1квадратов . 0, если элементов больше n+1.

 ш1.2
   Вычислим с использованием математического пакета MatLab  пример-
ные затраты времени на вычисления для случая n=37:
 ш1.0

   п x=[32 33 34 35 36]
   x = 32 33 34 35 36

   п y=[1.48 2.47 3.8 6.26 10.11]
   y = 1.48 2.47 3.80 6.26 10.11

   п P=polyfit(x,y,3)
   P = 1.0e+003 *
            0.0001 -0.0084 0.2720 -2.9311

 ш1.2
   Итак, функция y=y(x) приближённо описывается многочленом третьей
степени
 ш1.0

   P(x)=1.0e+003 77 0(0.0001x 53 0-0.0084x 52 0+0.2720x-2.9311).

 ш1.2
   Для вычисления значений многочлена при n=37 воспользуемся  функ-
цией
 ш1.0

   polyval(P,x),

где P - вектор коэффициентов многочлена, x - значение аргумента:

   п z=polyval(PA,37)
   z = 16.0340
 ш1.2

    2Пример 2.
 ш1.0

   > X:=[0,1,2,3,4,5]; Y:=[0,1,4,3,2,4];
                X:=[0,1,2,3,4,5]  Y:=[0,1,4,3,2,4]

   > f1:=spline(X,Y,x,linear);    fc:=spline(X,Y,x,cubic);
   > fq:=spline(X,Y,x,quadratic); fq1:=spline(X,Y,x,quartic):

                              7( 0   x,   x<1
                             │-2+3*x, x<2
                         f1:= 7* 0 6-x,   x<3
                             │ 6-x,   x<4
                              79 0-6+2*x, otherwise
                7( 0
                72 0   540 0/ 4209 77 0x+ 5169 0/ 4209 77 0x 53 0,                      x<1
               │                      5  0
               │   5596 0/ 4209 0- 592 0/ 411 77 0x+ 51788 0/ 4209 77 0x 52 0- 5427 0/ 4209 77 0x 53 0,   x<2
               │
           fc:= 7* 0-  55100 0/ 4209 0+ 56796 0/ 4209 77 0x- 52484 0/ 4209 77 0x 52 0+ 515 0/ 411 77 0x 53 0, 5  0x<3
               │                      5  0
               │- 566 0/ 419 0+ 52422 0/ 4209 77 0x- 554 0/ 411 77 0x 52 0+ 5123 0/ 4209 77 0x 53 0,    5   0 x<4
               │                          5  0
               │ 516746 0/ 4209 0- 510682 0/ 4209 77 0x+ 52250 0/ 4209 77 0x 52 0- 5150 0/ 4209 77 0x 53 0,
                79 0                                         otherwise

                7( 5 912 0/ 41189 77 0x 52 0,                    5   0      x< 51 0/ 42
               │
               │  5277 0/ 41189 0- 51108 0/ 41189 77 0x+ 52020 0/ 41189 77 0x 52 0,     x< 53 0/ 42
               │
               │- 512188 0/ 41189 0+ 515512 0/ 41189 77 0x- 53520 0/ 41189 77 0x 52 0,  x< 55 0/ 42
           fq:= 7* 0
               │  510287 0/ 41189 0- 52468 0/ 41189 77 0x+ 576 0/ 41189 77 0x 52 0,     x< 57 0/ 42
               │
               │  546890 0/ 41189 0- 523384 0/ 41189 77 0x+ 53064 0/ 41189 77 0x 52 0,  x< 59 0/ 42
               │
                79 0- 5100044 0/ 41189 0+ 541920 0/ 41189 77 0x- 54192 0/ 41189 77 0x 52 0, otherwise

   > plot([f1,fc,fq,fq1],x=-1..6.2,color=black);
 ш1.2

    2Пример 3. 0 Определим порядок сложности  2  0некоторого  алгоритма  по
результату компьютерного эксперимента.
   Пусть параметром алгоритма является n=6,  а время работы  компь-
ютера при этом значении - 54 с.
   Варианты экспериментальной функции сложности:
 ш1.0

    7a 0n,  7a 0n 1log 42 0n,  7a 0n 52 0,  7a 0n 53 0,  7a 0e 5n 0,  7a 0n!, n 7е ═R 0.

 ш1.2
   Для "правильно" подобранной экспериментальной функции 7 a 0=1, одна-
ко на практике допускается 7  01 7,a, 02.
   (1) Допустим, что f 4эксп 0= 7a 0n, тогда
 ш1.0

   6 7a 0=54 =>  7aЕ 0[1,2];

   (2) Допустим, что f 4эксп 0= 7a 0n 1log 42 0n, тогда

   6 7a 1log 42 06=54 => 7 a 0=9/ 1log 42 06>2 =>  7aЕ 0[1,2];

   (3) Допустим, что f 4эксп 0= 7a 0n 52 0, тогда

    7a 06 52 0=54 => 7 a 0=1.5 =>  7aе 0[1,2].

 ш1.2
   Итак, f 4эксп 0=1.5n 52 0.
   Теперь выскажем гипотезу о теоретической функции сложности:
 ш1.0
         4?
   f 4теор 0= 7O 0(n 52 0).
 ш1.2

                 2ЗАДАЧИ ДЛЯ САМОСТОЯТЕЛЬНОГО РЕШЕНИЯ
                                ...
